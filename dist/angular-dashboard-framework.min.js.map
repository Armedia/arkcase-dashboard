{"version":3,"sources":["adf.js","adf.locale.constants.js","column.js","dashboard.js","provider.js","row.js","widget-content.js","angular-dashboard-framework.min.js","widget.js","angular-dashboard-framework.tpl.js","angular-dashboard-framework.js"],"names":["window","undefined","angular","module","value","constant","defaultLocale","frameworkLocales","en-GB","ADF_COMMON_CLOSE","ADF_COMMON_DELETE","ADF_COMMON_TITLE","ADF_COMMON_CANCEL","ADF_COMMON_APPLY","ADF_COMMON_EDIT_DASHBOARD","ADF_EDIT_DASHBOARD_STRUCTURE_LABEL","ADF_DASHBOARD_TITLE_TOOLTIP_ADD","ADF_DASHBOARD_TITLE_TOOLTIP_SAVE","ADF_DASHBOARD_TITLE_TOOLTIP_EDIT_MODE","ADF_DASHBOARD_TITLE_TOOLTIP_UNDO","ADF_WIDGET_ADD_HEADER","ADF_WIDGET_DELETE_CONFIRM_MESSAGE","ADF_WIDGET_TOOLTIP_REFRESH","ADF_WIDGET_TOOLTIP_MOVE","ADF_WIDGET_TOOLTIP_COLLAPSE","ADF_WIDGET_TOOLTIP_EXPAND","ADF_WIDGET_TOOLTIP_EDIT","ADF_WIDGET_TOOLTIP_FULLSCREEN","ADF_WIDGET_TOOLTIP_REMOVE","sv-SE","directive","$log","$compile","adfTemplatePath","rowTemplate","dashboard","moveWidgetInColumn","$scope","column","evt","widgets","$apply","splice","newIndex","oldIndex","findWidget","index","widget","i","length","w","wid","findColumn","model","rows","r","j","columns","c","cid","getId","el","id","getAttribute","parseInt","addWidgetToColumn","targetColumn","from","sourceColumn","item","warn","removeWidgetFromColumn","applySortable","$element","sortable","Sortable","create","group","handle","ghostClass","animation","onAdd","onRemove","onUpdate","on","destroy","restrict","replace","scope","editMode","adfModel","options","templateUrl","link","col","isDefined","isArray","cloned","append","$rootScope","$modal","stringToBoolean","string","toLowerCase","Boolean","copyWidgets","source","target","shift","push","fillStructure","root","counter","forEach","row","readColumns","changeStructure","structure","copy","createConfiguration","type","cfg","config","findFirstWidgetColumn","error","addNewWidgetToModel","unshift","transclude","name","collapsible","editable","maximizable","adfWidgetFilter","controller","widgetFilter","structureName","$watch","oldVal","newVal","structures","title","titleTemplateUrl","editClass","translate","activeLocale","setLocale","toggleEditMode","modelCopy","$broadcast","$on","collapseAll","collapseExpandStatus","cancelEditMode","editDashboardDialog","editDashboardScope","$new","adfEditTemplatePath","editTemplateUrl","instance","open","backdrop","info","closeDialog","close","$destroy","addWidgetDialog","addScope","isFunction","adfAddTemplatePath","addTemplateUrl","opts","addWidget","$attr","enableConfirmDelete","enableconfirmdelete","provider","adfLocale","getLocales","locales","getActiveLocale","label","translation","this","locale","Error","addLocale","translations","isString","isObject","customWidgetTemplatePath","templatePath","widgetsPath","messageTemplate","loadingTemplate","extend","reload","edit","path","template","$get","columnTemplate","$q","$sce","$http","$templateCache","$controller","$injector","parseUrl","url","parsedUrl","indexOf","substring","getTemplate","deferred","defer","resolve","tpl","get","getTrustedResourceUrl","then","response","put","data","reject","promise","compileWidget","currentScope","content","html","templateScope","base","resolvers","$tpl","key","invoke","all","locals","templateCtrl","controllerAs","children","contents","reason","msg","preLink","definition","deleteTemplateUrl","fullscreenTemplateUrl","fromJson","widgetState","isCollapsed","debug","postLink","deleteWidget","remove","deleteScope","adfDeleteTemplatePath","deleteDialog","editScope","saveDialog","event","args","openFullScreen","fullScreenScope","size","modalSize","windowClass","compile","pre","post","run"],"mappings":"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","file":"angular-dashboard-framework.min.js","sourcesContent":["/*\n * The MIT License\n *\n * Copyright (c) 2015, Sebastian Sdorra\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n'use strict';\n\nangular.module('adf', ['adf.provider', 'ui.bootstrap'])\n    .value('adfTemplatePath', '../src/templates/')\n    .value('rowTemplate', '<adf-dashboard-row row=\"row\" adf-model=\"adfModel\" options=\"options\" edit-mode=\"editMode\" ng-repeat=\"row in column.rows\" />')\n    .value('columnTemplate', '<adf-dashboard-column column=\"column\" adf-model=\"adfModel\" options=\"options\" edit-mode=\"editMode\" ng-repeat=\"column in row.columns\" />')\n    .value('adfVersion', '<<adfVersion>>');\n","/*\n* The MIT License\n*\n* Copyright (c) 2015, Sebastian Sdorra\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in\n* all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\n'use strict';\n\n/**\n * @ngdoc object\n * @name adf.locale#adfLocale\n * @description\n *\n * Holds settings and values for framework supported locales\n */\nangular.module('adf.locale', [])\n    .constant('adfLocale',\n        {\n            defaultLocale: 'en-GB',\n            frameworkLocales: {\n                'en-GB': {\n                    ADF_COMMON_CLOSE: 'Close',\n                    ADF_COMMON_DELETE: 'Delete',\n                    ADF_COMMON_TITLE: 'Title',\n                    ADF_COMMON_CANCEL: 'Cancel',\n                    ADF_COMMON_APPLY: 'Apply',\n                    ADF_COMMON_EDIT_DASHBOARD: 'Edit dashboard',\n                    ADF_EDIT_DASHBOARD_STRUCTURE_LABEL: 'Structure',\n                    ADF_DASHBOARD_TITLE_TOOLTIP_ADD: 'Add new widget',\n                    ADF_DASHBOARD_TITLE_TOOLTIP_SAVE: 'Save changes',\n                    ADF_DASHBOARD_TITLE_TOOLTIP_EDIT_MODE: 'Enable edit mode',\n                    ADF_DASHBOARD_TITLE_TOOLTIP_UNDO: 'Undo changes',\n                    ADF_WIDGET_ADD_HEADER: 'Add new widget',\n                    ADF_WIDGET_DELETE_CONFIRM_MESSAGE: 'Are you sure you want to delete this widget ?',\n                    ADF_WIDGET_TOOLTIP_REFRESH: 'Reload widget Content',\n                    ADF_WIDGET_TOOLTIP_MOVE: 'Change widget location',\n                    ADF_WIDGET_TOOLTIP_COLLAPSE: 'Collapse widget',\n                    ADF_WIDGET_TOOLTIP_EXPAND: 'Expand widget',\n                    ADF_WIDGET_TOOLTIP_EDIT: 'Edit widget configuration',\n                    ADF_WIDGET_TOOLTIP_FULLSCREEN: 'Fullscreen widget',\n                    ADF_WIDGET_TOOLTIP_REMOVE: 'Remove widget'\n                },\n                'sv-SE': {\n                    ADF_COMMON_CLOSE: 'Stäng',\n                    ADF_COMMON_DELETE: 'Ta bort',\n                    ADF_COMMON_TITLE: 'Titel',\n                    ADF_COMMON_CANCEL: 'Avbryt',\n                    ADF_COMMON_APPLY: 'Använd',\n                    ADF_COMMON_EDIT_DASHBOARD: 'Redigera dashboard',\n                    ADF_EDIT_DASHBOARD_STRUCTURE_LABEL: 'Struktur',\n                    ADF_DASHBOARD_TITLE_TOOLTIP_ADD: 'Lägg till ny widget',\n                    ADF_DASHBOARD_TITLE_TOOLTIP_SAVE: 'Spara förändringar',\n                    ADF_DASHBOARD_TITLE_TOOLTIP_EDIT_MODE: 'Slå på redigeringsläge',\n                    ADF_DASHBOARD_TITLE_TOOLTIP_UNDO: 'Ångra förändringar',\n                    ADF_WIDGET_ADD_HEADER: 'Lägg till ny widget',\n                    ADF_WIDGET_DELETE_CONFIRM_MESSAGE: 'Är du säker på att du vill ta bort denna widget ?',\n                    ADF_WIDGET_TOOLTIP_REFRESH: 'Ladda om widget',\n                    ADF_WIDGET_TOOLTIP_MOVE: 'Ändra widgets position',\n                    ADF_WIDGET_TOOLTIP_COLLAPSE: 'Stäng widget',\n                    ADF_WIDGET_TOOLTIP_EXPAND: 'Öppna widget',\n                    ADF_WIDGET_TOOLTIP_EDIT: 'Ändra widget konfigurering',\n                    ADF_WIDGET_TOOLTIP_FULLSCREEN: 'Visa widget i fullskärm',\n                    ADF_WIDGET_TOOLTIP_REMOVE: 'Ta bort widget'\n                }\n            }\n        }\n    );\n\n","/*\n* The MIT License\n*\n* Copyright (c) 2015, Sebastian Sdorra\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in\n* all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\n\n/* global angular */\nangular.module('adf')\n    .directive('adfDashboardColumn', function ($log, $compile, adfTemplatePath, rowTemplate, dashboard) {\n        'use strict';\n\n        /**\n         * moves a widget in between a column\n         */\n        function moveWidgetInColumn($scope, column, evt) {\n            var widgets = column.widgets;\n            // move widget and apply to scope\n            $scope.$apply(function () {\n                widgets.splice(evt.newIndex, 0, widgets.splice(evt.oldIndex, 1)[0]);\n            });\n        }\n\n        /**\n         * finds a widget by its id in the column\n         */\n        function findWidget(column, index) {\n            var widget = null;\n            for (var i = 0; i < column.widgets.length; i++) {\n                var w = column.widgets[i];\n                if (w.wid === index) {\n                    widget = w;\n                    break;\n                }\n            }\n            return widget;\n        }\n\n        /**\n         * finds a column by its id in the model\n         */\n        function findColumn(model, index) {\n            var column = null;\n            for (var i = 0; i < model.rows.length; i++) {\n                var r = model.rows[i];\n                for (var j = 0; j < r.columns.length; j++) {\n                    var c = r.columns[j];\n                    if (c.cid === index) {\n                        column = c;\n                        break;\n                    } else if (c.rows) {\n                        column = findColumn(c, index);\n                    }\n                }\n                if (column) {\n                    break;\n                }\n            }\n            return column;\n        }\n\n        /**\n         * get the adf id from an html element\n         */\n        function getId(el) {\n            var id = el.getAttribute('adf-id');\n            return id ? parseInt(id) : -1;\n        }\n\n        /**\n         * adds a widget to a column\n         */\n        function addWidgetToColumn($scope, model, targetColumn, evt) {\n            // find source column\n            var cid = getId(evt.from);\n            var sourceColumn = findColumn(model, cid);\n\n            if (sourceColumn) {\n                // find moved widget\n                var wid = getId(evt.item);\n                var widget = findWidget(sourceColumn, wid);\n\n                if (widget) {\n                    // add new item and apply to scope\n                    $scope.$apply(function () {\n                        if (!targetColumn.widgets) {\n                            targetColumn.widgets = [];\n                        }\n\n                        targetColumn.widgets.splice(evt.newIndex, 0, widget);\n                    });\n                } else {\n                    $log.warn('could not find widget with id ' + wid);\n                }\n            } else {\n                $log.warn('could not find column with id ' + cid);\n            }\n        }\n\n        /**\n         * removes a widget from a column\n         */\n        function removeWidgetFromColumn($scope, column, evt) {\n            // remove old item and apply to scope\n            $scope.$apply(function () {\n                column.widgets.splice(evt.oldIndex, 1);\n            });\n        }\n\n        /**\n         * enable sortable\n         */\n        function applySortable($scope, $element, model, column) {\n            // enable drag and drop\n            var el = $element[0];\n            var sortable = Sortable.create(el, {\n                group: 'widgets',\n                handle: '.adf-move',\n                ghostClass: 'placeholder',\n                animation: 150,\n                onAdd: function (evt) {\n                    addWidgetToColumn($scope, model, column, evt);\n                },\n                onRemove: function (evt) {\n                    removeWidgetFromColumn($scope, column, evt);\n                },\n                onUpdate: function (evt) {\n                    moveWidgetInColumn($scope, column, evt);\n                }\n            });\n\n            // destroy sortable on column destroy event\n            $element.on('$destroy', function () {\n                sortable.destroy();\n            });\n        }\n\n        return {\n            restrict: 'E',\n            replace: true,\n            scope: {\n                column: '=',\n                editMode: '=',\n                adfModel: '=',\n                options: '='\n            },\n            templateUrl: adfTemplatePath + 'dashboard-column.html',\n            link: function ($scope, $element) {\n                // set id\n                var col = $scope.column;\n                if (!col.cid) {\n                    col.cid = dashboard.id();\n                }\n\n                if (angular.isDefined(col.rows) && angular.isArray(col.rows)) {\n                    // be sure to tell Angular about the injected directive and push the new row directive to the column\n                    $compile(rowTemplate)($scope, function (cloned) {\n                        $element.append(cloned);\n                    });\n                } else {\n                    // enable drag and drop for widget only columns\n                    applySortable($scope, $element, $scope.adfModel, col);\n                }\n            }\n        };\n    });\n","/*\n * The MIT License\n *\n * Copyright (c) 2015, Sebastian Sdorra\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n/**\n * @ngdoc directive\n * @name adf.directive:adfDashboard\n * @element div\n * @restrict EA\n * @scope\n * @description\n *\n * `adfDashboard` is a directive which renders the dashboard with all its\n * components. The directive requires a name attribute. The name of the\n * dashboard can be used to store the model.\n *\n * @param {string} name name of the dashboard. This attribute is required.\n * @param {boolean=} editable false to disable the editmode of the dashboard.\n * @param {boolean=} collapsible true to make widgets collapsible on the dashboard.\n * @param {boolean=} maximizable true to add a button for open widgets in a large modal panel.\n * @param {boolean=} enableConfirmDelete true to ask before remove an widget from the dashboard.\n * @param {string=} structure the default structure of the dashboard.\n * @param {object=} adfModel model object of the dashboard.\n * @param {function=} adfWidgetFilter function to filter widgets on the add dialog.\n */\n\nangular.module('adf')\n    .directive('adfDashboard', function ($rootScope, $log, $modal, dashboard, adfTemplatePath) {\n        'use strict';\n\n        function stringToBoolean(string) {\n            switch (angular.isDefined(string) ? string.toLowerCase() : null) {\n                case 'true':\n                case 'yes':\n                case '1':\n                    return true;\n                case 'false':\n                case 'no':\n                case '0':\n                case null:\n                    return false;\n                default:\n                    return Boolean(string);\n            }\n        }\n\n        function copyWidgets(source, target) {\n            if (source.widgets && source.widgets.length > 0) {\n                var w = source.widgets.shift();\n                while (w) {\n                    target.widgets.push(w);\n                    w = source.widgets.shift();\n                }\n            }\n        }\n\n        /**\n         * Copy widget from old columns to the new model\n         * @param object root the model\n         * @param array of columns\n         * @param counter\n         */\n        function fillStructure(root, columns, counter) {\n            counter = counter || 0;\n\n            if (angular.isDefined(root.rows)) {\n                angular.forEach(root.rows, function (row) {\n                    angular.forEach(row.columns, function (column) {\n                        // if the widgets prop doesn't exist, create a new array for it.\n                        // this allows ui.sortable to do it's thing without error\n                        if (!column.widgets) {\n                            column.widgets = [];\n                        }\n\n                        // if a column exist at the counter index, copy over the column\n                        if (angular.isDefined(columns[counter])) {\n                            // do not add widgets to a column, which uses nested rows\n                            if (!angular.isDefined(column.rows)) {\n                                copyWidgets(columns[counter], column);\n                                counter++;\n                            }\n                        }\n\n                        // run fillStructure again for any sub rows/columns\n                        counter = fillStructure(column, columns, counter);\n                    });\n                });\n            }\n            return counter;\n        }\n\n        /**\n         * Read Columns: recursively searches an object for the 'columns' property\n         * @param object model\n         * @param array  an array of existing columns; used when recursion happens\n         */\n        function readColumns(root, columns) {\n            columns = columns || [];\n\n            if (angular.isDefined(root.rows)) {\n                angular.forEach(root.rows, function (row) {\n                    angular.forEach(row.columns, function (col) {\n                        columns.push(col);\n                        // keep reading columns until we can't any more\n                        readColumns(col, columns);\n                    });\n                });\n            }\n\n            return columns;\n        }\n\n        function changeStructure(model, structure) {\n            var columns = readColumns(model);\n            var counter = 0;\n\n            model.rows = angular.copy(structure.rows);\n\n            while (counter < columns.length) {\n                counter = fillStructure(model, columns, counter);\n            }\n        }\n\n        function createConfiguration(type) {\n            var cfg = {};\n            var config = dashboard.widgets[type].config;\n            if (config) {\n                cfg = angular.copy(config);\n            }\n            return cfg;\n        }\n\n        /**\n         * Find first widget column in model.\n         *\n         * @param dashboard model\n         */\n        function findFirstWidgetColumn(model) {\n            var column = null;\n            if (!angular.isArray(model.rows)) {\n                $log.error('model does not have any rows');\n                return null;\n            }\n            for (var i = 0; i < model.rows.length; i++) {\n                var row = model.rows[i];\n                if (angular.isArray(row.columns)) {\n                    for (var j = 0; j < row.columns.length; j++) {\n                        var col = row.columns[j];\n                        if (!col.rows) {\n                            column = col;\n                            break;\n                        }\n                    }\n                }\n                if (column) {\n                    break;\n                }\n            }\n            return column;\n        }\n\n        /**\n         * Adds the widget to first column of the model.\n         *\n         * @param dashboard model\n         * @param widget to add to model\n         */\n        function addNewWidgetToModel(model, widget) {\n            if (model) {\n                var column = findFirstWidgetColumn(model);\n                if (column) {\n                    if (!column.widgets) {\n                        column.widgets = [];\n                    }\n                    column.widgets.unshift(widget);\n                } else {\n                    $log.error('could not find first widget column');\n                }\n            } else {\n                $log.error('model is undefined');\n            }\n        }\n\n        return {\n            replace: true,\n            restrict: 'EA',\n            transclude: false,\n            scope: {\n                structure: '@',\n                name: '@',\n                collapsible: '@',\n                editable: '@',\n                maximizable: '@',\n                adfModel: '=',\n                adfWidgetFilter: '='\n            },\n            controller: function ($scope) {\n                var model = {};\n                var structure = {};\n                var widgetFilter = null;\n                var structureName = {};\n                var name = $scope.name;\n\n                // Watching for changes on adfModel\n                $scope.$watch('adfModel', function (oldVal, newVal) {\n                    // has model changed or is the model attribute not set\n                    if (newVal !== null || (oldVal === null && newVal === null)) {\n                        model = $scope.adfModel;\n                        widgetFilter = $scope.adfWidgetFilter;\n                        if (!model || !model.rows) {\n                            structureName = $scope.structure;\n                            structure = dashboard.structures[structureName];\n                            if (structure) {\n                                if (model) {\n                                    model.rows = angular.copy(structure).rows;\n                                } else {\n                                    model = angular.copy(structure);\n                                }\n                                model.structure = structureName;\n                            } else {\n                                $log.error('could not find structure ' + structureName);\n                            }\n                        }\n\n                        if (model) {\n                            if (!model.title) {\n                                model.title = 'Dashboard';\n                            }\n                            if (!model.titleTemplateUrl) {\n                                model.titleTemplateUrl = adfTemplatePath + 'dashboard-title.html';\n                            }\n                            $scope.model = model;\n                        } else {\n                            $log.error('could not find or create model');\n                        }\n                    }\n                }, true);\n\n                // edit mode\n                $scope.editMode = false;\n                $scope.editClass = '';\n\n                $scope.translate = dashboard.translate;\n                var activeLocale = dashboard.activeLocale();\n                if (activeLocale) {\n                    dashboard.setLocale(activeLocale);\n                }\n\n                $scope.toggleEditMode = function () {\n                    $scope.editMode = !$scope.editMode;\n                    if ($scope.editMode) {\n                        $scope.modelCopy = angular.copy($scope.adfModel, {});\n                        $rootScope.$broadcast('adfDashboardEditMode', name, model);\n                    }\n\n                    if (!$scope.editMode) {\n                        $rootScope.$broadcast('adfDashboardChanged', name, model);\n                    }\n                };\n\n                $scope.$on('adfDashboardRetrieveChangedModel', function () {\n                    $rootScope.$broadcast('adfDashboardChanged', name, model);\n                });\n\n                $scope.collapseAll = function (collapseExpandStatus) {\n                    $rootScope.$broadcast('adfDashboardCollapseExapand', {collapseExpandStatus: collapseExpandStatus});\n                };\n\n                $scope.cancelEditMode = function () {\n                    $scope.editMode = false;\n                    $scope.modelCopy = angular.copy($scope.modelCopy, $scope.adfModel);\n                    $rootScope.$broadcast('adfDashboardEditsCancelled');\n                };\n\n                // edit dashboard settings\n                $scope.editDashboardDialog = function () {\n                    var editDashboardScope = $scope.$new();\n                    // create a copy of the title, to avoid changing the title to\n                    // \"dashboard\" if the field is empty\n                    editDashboardScope.copy = {\n                        title: model.title\n                    };\n                    editDashboardScope.structures = dashboard.structures;\n\n                    var adfEditTemplatePath = adfTemplatePath + 'dashboard-edit.html';\n                    if (model.editTemplateUrl) {\n                        adfEditTemplatePath = model.editTemplateUrl;\n                    }\n                    var instance = $modal.open({\n                        scope: editDashboardScope,\n                        templateUrl: adfEditTemplatePath,\n                        backdrop: 'static'\n                    });\n                    $scope.changeStructure = function (name, structure) {\n                        $log.info('change structure to ' + name);\n                        changeStructure(model, structure);\n                    };\n                    editDashboardScope.closeDialog = function () {\n                        // copy the new title back to the model\n                        model.title = editDashboardScope.copy.title;\n                        // close modal and destroy the scope\n                        instance.close();\n                        editDashboardScope.$destroy();\n                    };\n                };\n\n                // add widget dialog\n                $scope.addWidgetDialog = function () {\n                    var addScope = $scope.$new();\n                    var model = $scope.model;\n                    var widgets;\n                    if (angular.isFunction(widgetFilter)) {\n                        widgets = {};\n                        angular.forEach(dashboard.widgets, function (widget, type) {\n                            if (widgetFilter(widget, type, model)) {\n                                widgets[type] = widget;\n                            }\n                        });\n                    } else {\n                        widgets = dashboard.widgets;\n                    }\n                    addScope.widgets = widgets;\n\n                    //pass translate function to the new scope so we can translate the labels inside the modal dialog\n                    addScope.translate = $scope.translate;\n\n                    var adfAddTemplatePath = adfTemplatePath + 'widget-add.html';\n                    if (model.addTemplateUrl) {\n                        adfAddTemplatePath = model.addTemplateUrl;\n                    }\n\n                    var opts = {\n                        scope: addScope,\n                        templateUrl: adfAddTemplatePath,\n                        backdrop: 'static'\n                    };\n                    var instance = $modal.open(opts);\n                    addScope.addWidget = function (widget) {\n                        var w = {\n                            type: widget,\n                            config: createConfiguration(widget)\n                        };\n                        addNewWidgetToModel(model, w);\n                        $rootScope.$broadcast('adfWidgetAdded', name, model, w);\n                        // close and destroy\n                        instance.close();\n                        addScope.$destroy();\n                    };\n                    addScope.closeDialog = function () {\n                        // close and destroy\n                        instance.close();\n                        addScope.$destroy();\n                    };\n                };\n            },\n            link: function ($scope, $element, $attr) {\n                // pass options to scope\n                var options = {\n                    name: $attr.name,\n                    editable: true,\n                    enableConfirmDelete: stringToBoolean($attr.enableconfirmdelete),\n                    maximizable: stringToBoolean($attr.maximizable),\n                    collapsible: stringToBoolean($attr.collapsible)\n                };\n                if (angular.isDefined($attr.editable)) {\n                    options.editable = stringToBoolean($attr.editable);\n                }\n                $scope.options = options;\n            },\n            templateUrl: adfTemplatePath + 'dashboard.html'\n        };\n    });\n","/*\n * The MIT License\n *\n * Copyright (c) 2015, Sebastian Sdorra\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n'use strict';\n\n/**\n * @ngdoc object\n * @name adf.dashboardProvider\n * @description\n *\n * The dashboardProvider can be used to register structures and widgets.\n */\nangular.module('adf.provider', ['adf.locale'])\n    .provider('dashboard', function (adfLocale) {\n\n        var activeLocale = adfLocale.defaultLocale;\n        var locales = adfLocale.frameworkLocales;\n\n        function getLocales() {\n            return locales;\n        }\n\n        function getActiveLocale() {\n            return activeLocale;\n        }\n\n        function translate(label) {\n            var translation = locales[activeLocale][label];\n            return translation ? translation : label;\n        }\n\n        this.setLocale = function (locale) {\n            if (locales[locale]) {\n                activeLocale = locale;\n            } else {\n                throw new Error('Cannot set locale: ' + locale + '. Locale is not defined.');\n            }\n\n            return this;\n        };\n        this.addLocale = function (locale, translations) {\n            if (!angular.isString(locale)) {\n                throw new Error('locale must be an string');\n            }\n\n            if (!angular.isObject(translations)) {\n                throw new Error('translations must be an object');\n            }\n\n            locales[locale] = translations;\n            return this;\n        };\n\n        var customWidgetTemplatePath = null;\n\n        /**\n         * @ngdoc method\n         * @name adf.dashboardProvider#customWidgetTemplatePath\n         * @propertyOf adf.dashboardProvider\n         * @description\n         *\n         * Changes the container template for the widgets\n         *\n         * @param {string} path to the custom widget template\n         *\n         * @returns {Object} self\n         */\n        this.customWidgetTemplatePath = function (templatePath) {\n            customWidgetTemplatePath = templatePath;\n            return this;\n        };\n\n        var widgets = {};\n        var widgetsPath = '';\n        var structures = {};\n        var messageTemplate = '<div class=\"alert alert-danger\">{}</div>';\n        var loadingTemplate = '\\\n      <div class=\"progress progress-striped active\">\\n\\\n        <div class=\"progress-bar\" role=\"progressbar\" style=\"width: 100%\">\\n\\\n          <span class=\"sr-only\">loading ...</span>\\n\\\n        </div>\\n\\\n      </div>';\n\n        /**\n         * @ngdoc method\n         * @name adf.dashboardProvider#widget\n         * @methodOf adf.dashboardProvider\n         * @description\n         *\n         * Registers a new widget.\n         *\n         * @param {string} name of the widget\n         * @param {object} widget to be registered.\n         *\n         *   Object properties:\n         *\n         *   - `title` - `{string=}` - The title of the widget.\n         *   - `description` - `{string=}` - Description of the widget.\n         *   - `config` - `{object}` - Predefined widget configuration.\n         *   - `controller` - `{string=|function()=}` - Controller fn that should be\n         *      associated with newly created scope of the widget or the name of a\n         *      {@link http://docs.angularjs.org/api/angular.Module#controller registered controller}\n         *      if passed as a string.\n         *   - `controllerAs` - `{string=}` - A controller alias name. If present the controller will be\n         *      published to scope under the `controllerAs` name.\n         *   - `template` - `{string=|function()=}` - html template as a string.\n         *   - `templateUrl` - `{string=}` - path to an html template.\n         *   - `reload` - `{boolean=}` - true if the widget could be reloaded. The default is false.\n         *   - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\n         *      be injected into the controller. If any of these dependencies are promises, the widget\n         *      will wait for them all to be resolved or one to be rejected before the controller is\n         *      instantiated.\n         *      If all the promises are resolved successfully, the values of the resolved promises are\n         *      injected.\n         *\n         *      The map object is:\n         *      - `key` – `{string}`: a name of a dependency to be injected into the controller.\n         *      - `factory` - `{string|function}`: If `string` then it is an alias for a service.\n         *        Otherwise if function, then it is {@link http://docs.angularjs.org/api/AUTO.$injector#invoke injected}\n         *        and the return value is treated as the dependency. If the result is a promise, it is\n         *        resolved before its value is injected into the controller.\n         *   - `edit` - `{object}` - Edit modus of the widget.\n         *      - `controller` - `{string=|function()=}` - Same as above, but for the edit mode of the widget.\n         *      - `template` - `{string=|function()=}` - Same as above, but for the edit mode of the widget.\n         *      - `templateUrl` - `{string=}` - Same as above, but for the edit mode of the widget.\n         *      - `resolve` - `{Object.<string, function>=}` - Same as above, but for the edit mode of the widget.\n         *      - `reload` - {boolean} - true if the widget should be reloaded, after the edit mode is closed.\n         *        Default is true.\n         *\n         * @returns {Object} self\n         */\n        this.widget = function (name, widget) {\n            var w = angular.extend({reload: false}, widget);\n            if (w.edit) {\n                var edit = {reload: true};\n                angular.extend(edit, w.edit);\n                w.edit = edit;\n            }\n            widgets[name] = w;\n            return this;\n        };\n\n        /**\n         * @ngdoc method\n         * @name adf.dashboardProvider#widgetsPath\n         * @methodOf adf.dashboardProvider\n         * @description\n         *\n         * Sets the path to the directory which contains the widgets. The widgets\n         * path is used for widgets with a templateUrl which contains the\n         * placeholder {widgetsPath}. The placeholder is replaced with the\n         * configured value, before the template is loaded, but the template is\n         * cached with the unmodified templateUrl (e.g.: {widgetPath}/src/widgets).\n         * The default value of widgetPaths is ''.\n         *\n         *\n         * @param {string} path to the directory which contains the widgets\n         *\n         * @returns {Object} self\n         */\n        this.widgetsPath = function (path) {\n            widgetsPath = path;\n            return this;\n        };\n\n        /**\n         * @ngdoc method\n         * @name adf.dashboardProvider#structure\n         * @methodOf adf.dashboardProvider\n         * @description\n         *\n         * Registers a new structure.\n         *\n         * @param {string} name of the structure\n         * @param {object} structure to be registered.\n         *\n         *   Object properties:\n         *\n         *   - `rows` - `{Array.<Object>}` - Rows of the dashboard structure.\n         *     - `styleClass` - `{string}` - CSS Class of the row.\n         *     - `columns` - `{Array.<Object>}` - Columns of the row.\n         *       - `styleClass` - `{string}` - CSS Class of the column.\n         *\n         * @returns {Object} self\n         */\n        this.structure = function (name, structure) {\n            structures[name] = structure;\n            return this;\n        };\n\n        /**\n         * @ngdoc method\n         * @name adf.dashboardProvider#messageTemplate\n         * @methodOf adf.dashboardProvider\n         * @description\n         *\n         * Changes the template for messages.\n         *\n         * @param {string} template for messages.\n         *\n         * @returns {Object} self\n         */\n        this.messageTemplate = function (template) {\n            messageTemplate = template;\n            return this;\n        };\n\n        /**\n         * @ngdoc method\n         * @name adf.dashboardProvider#loadingTemplate\n         * @methodOf adf.dashboardProvider\n         * @description\n         *\n         * Changes the template which is displayed as\n         * long as the widget resources are not resolved.\n         *\n         * @param {string} loading template\n         *\n         * @returns {Object} self\n         */\n        this.loadingTemplate = function (template) {\n            loadingTemplate = template;\n            return this;\n        };\n\n        /**\n         * @ngdoc service\n         * @name adf.dashboard\n         * @description\n         *\n         * The dashboard holds all options, structures and widgets.\n         *\n         * @property {Array.<Object>} widgets Array of registered widgets.\n         * @property {string} widgetsPath Default path for widgets.\n         * @property {Array.<Object>} structures Array of registered structures.\n         * @property {string} messageTemplate Template for messages.\n         * @property {string} loadingTemplate Template for widget loading.\n         *\n         * @returns {Object} self\n         */\n        this.$get = function () {\n            var cid = 0;\n\n            return {\n                widgets: widgets,\n                widgetsPath: widgetsPath,\n                structures: structures,\n                messageTemplate: messageTemplate,\n                loadingTemplate: loadingTemplate,\n                setLocale: this.setLocale,\n                locales: getLocales,\n                activeLocale: getActiveLocale,\n                translate: translate,\n                customWidgetTemplatePath: customWidgetTemplatePath,\n\n                /**\n                 * @ngdoc method\n                 * @name adf.dashboard#id\n                 * @methodOf adf.dashboard\n                 * @description\n                 *\n                 * Creates an ongoing numeric id. The method is used to create ids for\n                 * columns and widgets in the dashboard.\n                 */\n                id: function () {\n                    return ++cid;\n                }\n            };\n        };\n\n    });\n","/*\n* The MIT License\n*\n* Copyright (c) 2015, Sebastian Sdorra\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in\n* all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\n\n/* global angular */\nangular.module('adf')\n    .directive('adfDashboardRow', function ($compile, adfTemplatePath, columnTemplate) {\n        'use strict';\n\n        return {\n            restrict: 'E',\n            replace: true,\n            scope: {\n                row: '=',\n                adfModel: '=',\n                editMode: '=',\n                options: '='\n            },\n            templateUrl: adfTemplatePath + 'dashboard-row.html',\n            link: function ($scope, $element) {\n                if (angular.isDefined($scope.row.columns) && angular.isArray($scope.row.columns)) {\n                    $compile(columnTemplate)($scope, function (cloned) {\n                        $element.append(cloned);\n                    });\n                }\n            }\n        };\n    });\n","/*\n * The MIT License\n *\n * Copyright (c) 2015, Sebastian Sdorra\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n'use strict';\n\nangular.module('adf')\n    .directive('adfWidgetContent', function ($log, $q, $sce, $http, $templateCache,\n                                             $compile, $controller, $injector, dashboard) {\n\n        function parseUrl(url) {\n            var parsedUrl = url;\n            if (url.indexOf('{widgetsPath}') >= 0) {\n                parsedUrl = url.replace('{widgetsPath}', dashboard.widgetsPath)\n                    .replace('//', '/');\n                if (parsedUrl.indexOf('/') === 0) {\n                    parsedUrl = parsedUrl.substring(1);\n                }\n            }\n            return parsedUrl;\n        }\n\n        function getTemplate(widget) {\n            var deferred = $q.defer();\n\n            if (widget.template) {\n                deferred.resolve(widget.template);\n            } else if (widget.templateUrl) {\n                // try to fetch template from cache\n                var tpl = $templateCache.get(widget.templateUrl);\n                if (tpl) {\n                    deferred.resolve(tpl);\n                } else {\n                    var url = $sce.getTrustedResourceUrl(parseUrl(widget.templateUrl));\n                    //$http.get(url)\n                    //  .success(function(response){\n                    //    // put response to cache, with unmodified url as key\n                    //    $templateCache.put(widget.templateUrl, response);\n                    //    deferred.resolve(response);\n                    //  })\n                    //  .error(function(){\n                    //    deferred.reject('could not load template');\n                    //  });\n\n                    //jwu: above code not working\n                    $http.get(url).then(function (response) {\n                        // put response to cache, with unmodified url as key\n                        $templateCache.put(widget.templateUrl, response.data);\n                        deferred.resolve(response.data);\n                    }, (function () {\n                        deferred.reject('could not load template');\n                    }));\n                }\n            }\n\n            return deferred.promise;\n        }\n\n        function compileWidget($scope, $element, currentScope) {\n            var model = $scope.model;\n            var content = $scope.content;\n\n            // display loading template\n            $element.html(dashboard.loadingTemplate);\n\n            // create new scope\n            var templateScope = $scope.$new();\n\n            // pass config object to scope\n            if (!model.config) {\n                model.config = {};\n            }\n\n            templateScope.config = model.config;\n\n            // local injections\n            var base = {\n                $scope: templateScope,\n                widget: model,\n                config: model.config\n            };\n\n            // get resolve promises from content object\n            var resolvers = {};\n            resolvers.$tpl = getTemplate(content);\n            if (content.resolve) {\n                angular.forEach(content.resolve, function (promise, key) {\n                    if (angular.isString(promise)) {\n                        resolvers[key] = $injector.get(promise);\n                    } else {\n                        resolvers[key] = $injector.invoke(promise, promise, base);\n                    }\n                });\n            }\n\n            // resolve all resolvers\n            $q.all(resolvers).then(function (locals) {\n                angular.extend(locals, base);\n\n                // compile & render template\n                var template = locals.$tpl;\n                $element.html(template);\n                if (content.controller) {\n                    var templateCtrl = $controller(content.controller, locals);\n                    if (content.controllerAs) {\n                        templateScope[content.controllerAs] = templateCtrl;\n                    }\n                    $element.children().data('$ngControllerController', templateCtrl);\n                }\n                $compile($element.contents())(templateScope);\n            }, function (reason) {\n                // handle promise rejection\n                var msg = 'Could not resolve all promises';\n                if (reason) {\n                    msg += ': ' + reason;\n                }\n                $log.warn(msg);\n                $element.html(dashboard.messageTemplate.replace(/{}/g, msg));\n            });\n\n            // destroy old scope\n            if (currentScope) {\n                currentScope.$destroy();\n            }\n\n            return templateScope;\n        }\n\n        return {\n            replace: true,\n            restrict: 'EA',\n            transclude: false,\n            scope: {\n                model: '=',\n                content: '='\n            },\n            link: function ($scope, $element) {\n                var currentScope = compileWidget($scope, $element, null);\n                $scope.$on('widgetConfigChanged', function () {\n                    currentScope = compileWidget($scope, $element, currentScope);\n                });\n                $scope.$on('widgetReload', function () {\n                    currentScope = compileWidget($scope, $element, currentScope);\n                });\n            }\n        };\n\n    });\n","(function(window, undefined) {'use strict';\n/*\n * The MIT License\n *\n * Copyright (c) 2015, Sebastian Sdorra\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n\nangular.module('adf', ['adf.provider', 'ui.bootstrap'])\n    .value('adfTemplatePath', '../src/templates/')\n    .value('rowTemplate', '<adf-dashboard-row row=\"row\" adf-model=\"adfModel\" options=\"options\" edit-mode=\"editMode\" ng-repeat=\"row in column.rows\" />')\n    .value('columnTemplate', '<adf-dashboard-column column=\"column\" adf-model=\"adfModel\" options=\"options\" edit-mode=\"editMode\" ng-repeat=\"column in row.columns\" />')\n    .value('adfVersion', '0.10.1.1');\n\n/*\n* The MIT License\n*\n* Copyright (c) 2015, Sebastian Sdorra\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in\n* all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\n\n\n/**\n * @ngdoc object\n * @name adf.locale#adfLocale\n * @description\n *\n * Holds settings and values for framework supported locales\n */\nangular.module('adf.locale', [])\n    .constant('adfLocale',\n        {\n            defaultLocale: 'en-GB',\n            frameworkLocales: {\n                'en-GB': {\n                    ADF_COMMON_CLOSE: 'Close',\n                    ADF_COMMON_DELETE: 'Delete',\n                    ADF_COMMON_TITLE: 'Title',\n                    ADF_COMMON_CANCEL: 'Cancel',\n                    ADF_COMMON_APPLY: 'Apply',\n                    ADF_COMMON_EDIT_DASHBOARD: 'Edit dashboard',\n                    ADF_EDIT_DASHBOARD_STRUCTURE_LABEL: 'Structure',\n                    ADF_DASHBOARD_TITLE_TOOLTIP_ADD: 'Add new widget',\n                    ADF_DASHBOARD_TITLE_TOOLTIP_SAVE: 'Save changes',\n                    ADF_DASHBOARD_TITLE_TOOLTIP_EDIT_MODE: 'Enable edit mode',\n                    ADF_DASHBOARD_TITLE_TOOLTIP_UNDO: 'Undo changes',\n                    ADF_WIDGET_ADD_HEADER: 'Add new widget',\n                    ADF_WIDGET_DELETE_CONFIRM_MESSAGE: 'Are you sure you want to delete this widget ?',\n                    ADF_WIDGET_TOOLTIP_REFRESH: 'Reload widget Content',\n                    ADF_WIDGET_TOOLTIP_MOVE: 'Change widget location',\n                    ADF_WIDGET_TOOLTIP_COLLAPSE: 'Collapse widget',\n                    ADF_WIDGET_TOOLTIP_EXPAND: 'Expand widget',\n                    ADF_WIDGET_TOOLTIP_EDIT: 'Edit widget configuration',\n                    ADF_WIDGET_TOOLTIP_FULLSCREEN: 'Fullscreen widget',\n                    ADF_WIDGET_TOOLTIP_REMOVE: 'Remove widget'\n                },\n                'sv-SE': {\n                    ADF_COMMON_CLOSE: 'Stäng',\n                    ADF_COMMON_DELETE: 'Ta bort',\n                    ADF_COMMON_TITLE: 'Titel',\n                    ADF_COMMON_CANCEL: 'Avbryt',\n                    ADF_COMMON_APPLY: 'Använd',\n                    ADF_COMMON_EDIT_DASHBOARD: 'Redigera dashboard',\n                    ADF_EDIT_DASHBOARD_STRUCTURE_LABEL: 'Struktur',\n                    ADF_DASHBOARD_TITLE_TOOLTIP_ADD: 'Lägg till ny widget',\n                    ADF_DASHBOARD_TITLE_TOOLTIP_SAVE: 'Spara förändringar',\n                    ADF_DASHBOARD_TITLE_TOOLTIP_EDIT_MODE: 'Slå på redigeringsläge',\n                    ADF_DASHBOARD_TITLE_TOOLTIP_UNDO: 'Ångra förändringar',\n                    ADF_WIDGET_ADD_HEADER: 'Lägg till ny widget',\n                    ADF_WIDGET_DELETE_CONFIRM_MESSAGE: 'Är du säker på att du vill ta bort denna widget ?',\n                    ADF_WIDGET_TOOLTIP_REFRESH: 'Ladda om widget',\n                    ADF_WIDGET_TOOLTIP_MOVE: 'Ändra widgets position',\n                    ADF_WIDGET_TOOLTIP_COLLAPSE: 'Stäng widget',\n                    ADF_WIDGET_TOOLTIP_EXPAND: 'Öppna widget',\n                    ADF_WIDGET_TOOLTIP_EDIT: 'Ändra widget konfigurering',\n                    ADF_WIDGET_TOOLTIP_FULLSCREEN: 'Visa widget i fullskärm',\n                    ADF_WIDGET_TOOLTIP_REMOVE: 'Ta bort widget'\n                }\n            }\n        }\n    );\n\n\n/*\n* The MIT License\n*\n* Copyright (c) 2015, Sebastian Sdorra\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in\n* all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\n\n/* global angular */\nangular.module('adf')\n    .directive('adfDashboardColumn', [\"$log\", \"$compile\", \"adfTemplatePath\", \"rowTemplate\", \"dashboard\", function ($log, $compile, adfTemplatePath, rowTemplate, dashboard) {\n        \n\n        /**\n         * moves a widget in between a column\n         */\n        function moveWidgetInColumn($scope, column, evt) {\n            var widgets = column.widgets;\n            // move widget and apply to scope\n            $scope.$apply(function () {\n                widgets.splice(evt.newIndex, 0, widgets.splice(evt.oldIndex, 1)[0]);\n            });\n        }\n\n        /**\n         * finds a widget by its id in the column\n         */\n        function findWidget(column, index) {\n            var widget = null;\n            for (var i = 0; i < column.widgets.length; i++) {\n                var w = column.widgets[i];\n                if (w.wid === index) {\n                    widget = w;\n                    break;\n                }\n            }\n            return widget;\n        }\n\n        /**\n         * finds a column by its id in the model\n         */\n        function findColumn(model, index) {\n            var column = null;\n            for (var i = 0; i < model.rows.length; i++) {\n                var r = model.rows[i];\n                for (var j = 0; j < r.columns.length; j++) {\n                    var c = r.columns[j];\n                    if (c.cid === index) {\n                        column = c;\n                        break;\n                    } else if (c.rows) {\n                        column = findColumn(c, index);\n                    }\n                }\n                if (column) {\n                    break;\n                }\n            }\n            return column;\n        }\n\n        /**\n         * get the adf id from an html element\n         */\n        function getId(el) {\n            var id = el.getAttribute('adf-id');\n            return id ? parseInt(id) : -1;\n        }\n\n        /**\n         * adds a widget to a column\n         */\n        function addWidgetToColumn($scope, model, targetColumn, evt) {\n            // find source column\n            var cid = getId(evt.from);\n            var sourceColumn = findColumn(model, cid);\n\n            if (sourceColumn) {\n                // find moved widget\n                var wid = getId(evt.item);\n                var widget = findWidget(sourceColumn, wid);\n\n                if (widget) {\n                    // add new item and apply to scope\n                    $scope.$apply(function () {\n                        if (!targetColumn.widgets) {\n                            targetColumn.widgets = [];\n                        }\n\n                        targetColumn.widgets.splice(evt.newIndex, 0, widget);\n                    });\n                } else {\n                    $log.warn('could not find widget with id ' + wid);\n                }\n            } else {\n                $log.warn('could not find column with id ' + cid);\n            }\n        }\n\n        /**\n         * removes a widget from a column\n         */\n        function removeWidgetFromColumn($scope, column, evt) {\n            // remove old item and apply to scope\n            $scope.$apply(function () {\n                column.widgets.splice(evt.oldIndex, 1);\n            });\n        }\n\n        /**\n         * enable sortable\n         */\n        function applySortable($scope, $element, model, column) {\n            // enable drag and drop\n            var el = $element[0];\n            var sortable = Sortable.create(el, {\n                group: 'widgets',\n                handle: '.adf-move',\n                ghostClass: 'placeholder',\n                animation: 150,\n                onAdd: function (evt) {\n                    addWidgetToColumn($scope, model, column, evt);\n                },\n                onRemove: function (evt) {\n                    removeWidgetFromColumn($scope, column, evt);\n                },\n                onUpdate: function (evt) {\n                    moveWidgetInColumn($scope, column, evt);\n                }\n            });\n\n            // destroy sortable on column destroy event\n            $element.on('$destroy', function () {\n                sortable.destroy();\n            });\n        }\n\n        return {\n            restrict: 'E',\n            replace: true,\n            scope: {\n                column: '=',\n                editMode: '=',\n                adfModel: '=',\n                options: '='\n            },\n            templateUrl: adfTemplatePath + 'dashboard-column.html',\n            link: function ($scope, $element) {\n                // set id\n                var col = $scope.column;\n                if (!col.cid) {\n                    col.cid = dashboard.id();\n                }\n\n                if (angular.isDefined(col.rows) && angular.isArray(col.rows)) {\n                    // be sure to tell Angular about the injected directive and push the new row directive to the column\n                    $compile(rowTemplate)($scope, function (cloned) {\n                        $element.append(cloned);\n                    });\n                } else {\n                    // enable drag and drop for widget only columns\n                    applySortable($scope, $element, $scope.adfModel, col);\n                }\n            }\n        };\n    }]);\n\n/*\n * The MIT License\n *\n * Copyright (c) 2015, Sebastian Sdorra\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n/**\n * @ngdoc directive\n * @name adf.directive:adfDashboard\n * @element div\n * @restrict EA\n * @scope\n * @description\n *\n * `adfDashboard` is a directive which renders the dashboard with all its\n * components. The directive requires a name attribute. The name of the\n * dashboard can be used to store the model.\n *\n * @param {string} name name of the dashboard. This attribute is required.\n * @param {boolean=} editable false to disable the editmode of the dashboard.\n * @param {boolean=} collapsible true to make widgets collapsible on the dashboard.\n * @param {boolean=} maximizable true to add a button for open widgets in a large modal panel.\n * @param {boolean=} enableConfirmDelete true to ask before remove an widget from the dashboard.\n * @param {string=} structure the default structure of the dashboard.\n * @param {object=} adfModel model object of the dashboard.\n * @param {function=} adfWidgetFilter function to filter widgets on the add dialog.\n */\n\nangular.module('adf')\n    .directive('adfDashboard', [\"$rootScope\", \"$log\", \"$modal\", \"dashboard\", \"adfTemplatePath\", function ($rootScope, $log, $modal, dashboard, adfTemplatePath) {\n        \n\n        function stringToBoolean(string) {\n            switch (angular.isDefined(string) ? string.toLowerCase() : null) {\n                case 'true':\n                case 'yes':\n                case '1':\n                    return true;\n                case 'false':\n                case 'no':\n                case '0':\n                case null:\n                    return false;\n                default:\n                    return Boolean(string);\n            }\n        }\n\n        function copyWidgets(source, target) {\n            if (source.widgets && source.widgets.length > 0) {\n                var w = source.widgets.shift();\n                while (w) {\n                    target.widgets.push(w);\n                    w = source.widgets.shift();\n                }\n            }\n        }\n\n        /**\n         * Copy widget from old columns to the new model\n         * @param object root the model\n         * @param array of columns\n         * @param counter\n         */\n        function fillStructure(root, columns, counter) {\n            counter = counter || 0;\n\n            if (angular.isDefined(root.rows)) {\n                angular.forEach(root.rows, function (row) {\n                    angular.forEach(row.columns, function (column) {\n                        // if the widgets prop doesn't exist, create a new array for it.\n                        // this allows ui.sortable to do it's thing without error\n                        if (!column.widgets) {\n                            column.widgets = [];\n                        }\n\n                        // if a column exist at the counter index, copy over the column\n                        if (angular.isDefined(columns[counter])) {\n                            // do not add widgets to a column, which uses nested rows\n                            if (!angular.isDefined(column.rows)) {\n                                copyWidgets(columns[counter], column);\n                                counter++;\n                            }\n                        }\n\n                        // run fillStructure again for any sub rows/columns\n                        counter = fillStructure(column, columns, counter);\n                    });\n                });\n            }\n            return counter;\n        }\n\n        /**\n         * Read Columns: recursively searches an object for the 'columns' property\n         * @param object model\n         * @param array  an array of existing columns; used when recursion happens\n         */\n        function readColumns(root, columns) {\n            columns = columns || [];\n\n            if (angular.isDefined(root.rows)) {\n                angular.forEach(root.rows, function (row) {\n                    angular.forEach(row.columns, function (col) {\n                        columns.push(col);\n                        // keep reading columns until we can't any more\n                        readColumns(col, columns);\n                    });\n                });\n            }\n\n            return columns;\n        }\n\n        function changeStructure(model, structure) {\n            var columns = readColumns(model);\n            var counter = 0;\n\n            model.rows = angular.copy(structure.rows);\n\n            while (counter < columns.length) {\n                counter = fillStructure(model, columns, counter);\n            }\n        }\n\n        function createConfiguration(type) {\n            var cfg = {};\n            var config = dashboard.widgets[type].config;\n            if (config) {\n                cfg = angular.copy(config);\n            }\n            return cfg;\n        }\n\n        /**\n         * Find first widget column in model.\n         *\n         * @param dashboard model\n         */\n        function findFirstWidgetColumn(model) {\n            var column = null;\n            if (!angular.isArray(model.rows)) {\n                $log.error('model does not have any rows');\n                return null;\n            }\n            for (var i = 0; i < model.rows.length; i++) {\n                var row = model.rows[i];\n                if (angular.isArray(row.columns)) {\n                    for (var j = 0; j < row.columns.length; j++) {\n                        var col = row.columns[j];\n                        if (!col.rows) {\n                            column = col;\n                            break;\n                        }\n                    }\n                }\n                if (column) {\n                    break;\n                }\n            }\n            return column;\n        }\n\n        /**\n         * Adds the widget to first column of the model.\n         *\n         * @param dashboard model\n         * @param widget to add to model\n         */\n        function addNewWidgetToModel(model, widget) {\n            if (model) {\n                var column = findFirstWidgetColumn(model);\n                if (column) {\n                    if (!column.widgets) {\n                        column.widgets = [];\n                    }\n                    column.widgets.unshift(widget);\n                } else {\n                    $log.error('could not find first widget column');\n                }\n            } else {\n                $log.error('model is undefined');\n            }\n        }\n\n        return {\n            replace: true,\n            restrict: 'EA',\n            transclude: false,\n            scope: {\n                structure: '@',\n                name: '@',\n                collapsible: '@',\n                editable: '@',\n                maximizable: '@',\n                adfModel: '=',\n                adfWidgetFilter: '='\n            },\n            controller: [\"$scope\", function ($scope) {\n                var model = {};\n                var structure = {};\n                var widgetFilter = null;\n                var structureName = {};\n                var name = $scope.name;\n\n                // Watching for changes on adfModel\n                $scope.$watch('adfModel', function (oldVal, newVal) {\n                    // has model changed or is the model attribute not set\n                    if (newVal !== null || (oldVal === null && newVal === null)) {\n                        model = $scope.adfModel;\n                        widgetFilter = $scope.adfWidgetFilter;\n                        if (!model || !model.rows) {\n                            structureName = $scope.structure;\n                            structure = dashboard.structures[structureName];\n                            if (structure) {\n                                if (model) {\n                                    model.rows = angular.copy(structure).rows;\n                                } else {\n                                    model = angular.copy(structure);\n                                }\n                                model.structure = structureName;\n                            } else {\n                                $log.error('could not find structure ' + structureName);\n                            }\n                        }\n\n                        if (model) {\n                            if (!model.title) {\n                                model.title = 'Dashboard';\n                            }\n                            if (!model.titleTemplateUrl) {\n                                model.titleTemplateUrl = adfTemplatePath + 'dashboard-title.html';\n                            }\n                            $scope.model = model;\n                        } else {\n                            $log.error('could not find or create model');\n                        }\n                    }\n                }, true);\n\n                // edit mode\n                $scope.editMode = false;\n                $scope.editClass = '';\n\n                $scope.translate = dashboard.translate;\n                var activeLocale = dashboard.activeLocale();\n                if (activeLocale) {\n                    dashboard.setLocale(activeLocale);\n                }\n\n                $scope.toggleEditMode = function () {\n                    $scope.editMode = !$scope.editMode;\n                    if ($scope.editMode) {\n                        $scope.modelCopy = angular.copy($scope.adfModel, {});\n                        $rootScope.$broadcast('adfDashboardEditMode', name, model);\n                    }\n\n                    if (!$scope.editMode) {\n                        $rootScope.$broadcast('adfDashboardChanged', name, model);\n                    }\n                };\n\n                $scope.$on('adfDashboardRetrieveChangedModel', function () {\n                    $rootScope.$broadcast('adfDashboardChanged', name, model);\n                });\n\n                $scope.collapseAll = function (collapseExpandStatus) {\n                    $rootScope.$broadcast('adfDashboardCollapseExapand', {collapseExpandStatus: collapseExpandStatus});\n                };\n\n                $scope.cancelEditMode = function () {\n                    $scope.editMode = false;\n                    $scope.modelCopy = angular.copy($scope.modelCopy, $scope.adfModel);\n                    $rootScope.$broadcast('adfDashboardEditsCancelled');\n                };\n\n                // edit dashboard settings\n                $scope.editDashboardDialog = function () {\n                    var editDashboardScope = $scope.$new();\n                    // create a copy of the title, to avoid changing the title to\n                    // \"dashboard\" if the field is empty\n                    editDashboardScope.copy = {\n                        title: model.title\n                    };\n                    editDashboardScope.structures = dashboard.structures;\n\n                    var adfEditTemplatePath = adfTemplatePath + 'dashboard-edit.html';\n                    if (model.editTemplateUrl) {\n                        adfEditTemplatePath = model.editTemplateUrl;\n                    }\n                    var instance = $modal.open({\n                        scope: editDashboardScope,\n                        templateUrl: adfEditTemplatePath,\n                        backdrop: 'static'\n                    });\n                    $scope.changeStructure = function (name, structure) {\n                        $log.info('change structure to ' + name);\n                        changeStructure(model, structure);\n                    };\n                    editDashboardScope.closeDialog = function () {\n                        // copy the new title back to the model\n                        model.title = editDashboardScope.copy.title;\n                        // close modal and destroy the scope\n                        instance.close();\n                        editDashboardScope.$destroy();\n                    };\n                };\n\n                // add widget dialog\n                $scope.addWidgetDialog = function () {\n                    var addScope = $scope.$new();\n                    var model = $scope.model;\n                    var widgets;\n                    if (angular.isFunction(widgetFilter)) {\n                        widgets = {};\n                        angular.forEach(dashboard.widgets, function (widget, type) {\n                            if (widgetFilter(widget, type, model)) {\n                                widgets[type] = widget;\n                            }\n                        });\n                    } else {\n                        widgets = dashboard.widgets;\n                    }\n                    addScope.widgets = widgets;\n\n                    //pass translate function to the new scope so we can translate the labels inside the modal dialog\n                    addScope.translate = $scope.translate;\n\n                    var adfAddTemplatePath = adfTemplatePath + 'widget-add.html';\n                    if (model.addTemplateUrl) {\n                        adfAddTemplatePath = model.addTemplateUrl;\n                    }\n\n                    var opts = {\n                        scope: addScope,\n                        templateUrl: adfAddTemplatePath,\n                        backdrop: 'static'\n                    };\n                    var instance = $modal.open(opts);\n                    addScope.addWidget = function (widget) {\n                        var w = {\n                            type: widget,\n                            config: createConfiguration(widget)\n                        };\n                        addNewWidgetToModel(model, w);\n                        $rootScope.$broadcast('adfWidgetAdded', name, model, w);\n                        // close and destroy\n                        instance.close();\n                        addScope.$destroy();\n                    };\n                    addScope.closeDialog = function () {\n                        // close and destroy\n                        instance.close();\n                        addScope.$destroy();\n                    };\n                };\n            }],\n            link: function ($scope, $element, $attr) {\n                // pass options to scope\n                var options = {\n                    name: $attr.name,\n                    editable: true,\n                    enableConfirmDelete: stringToBoolean($attr.enableconfirmdelete),\n                    maximizable: stringToBoolean($attr.maximizable),\n                    collapsible: stringToBoolean($attr.collapsible)\n                };\n                if (angular.isDefined($attr.editable)) {\n                    options.editable = stringToBoolean($attr.editable);\n                }\n                $scope.options = options;\n            },\n            templateUrl: adfTemplatePath + 'dashboard.html'\n        };\n    }]);\n\n/*\n * The MIT License\n *\n * Copyright (c) 2015, Sebastian Sdorra\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n\n/**\n * @ngdoc object\n * @name adf.dashboardProvider\n * @description\n *\n * The dashboardProvider can be used to register structures and widgets.\n */\nangular.module('adf.provider', ['adf.locale'])\n    .provider('dashboard', [\"adfLocale\", function (adfLocale) {\n\n        var activeLocale = adfLocale.defaultLocale;\n        var locales = adfLocale.frameworkLocales;\n\n        function getLocales() {\n            return locales;\n        }\n\n        function getActiveLocale() {\n            return activeLocale;\n        }\n\n        function translate(label) {\n            var translation = locales[activeLocale][label];\n            return translation ? translation : label;\n        }\n\n        this.setLocale = function (locale) {\n            if (locales[locale]) {\n                activeLocale = locale;\n            } else {\n                throw new Error('Cannot set locale: ' + locale + '. Locale is not defined.');\n            }\n\n            return this;\n        };\n        this.addLocale = function (locale, translations) {\n            if (!angular.isString(locale)) {\n                throw new Error('locale must be an string');\n            }\n\n            if (!angular.isObject(translations)) {\n                throw new Error('translations must be an object');\n            }\n\n            locales[locale] = translations;\n            return this;\n        };\n\n        var customWidgetTemplatePath = null;\n\n        /**\n         * @ngdoc method\n         * @name adf.dashboardProvider#customWidgetTemplatePath\n         * @propertyOf adf.dashboardProvider\n         * @description\n         *\n         * Changes the container template for the widgets\n         *\n         * @param {string} path to the custom widget template\n         *\n         * @returns {Object} self\n         */\n        this.customWidgetTemplatePath = function (templatePath) {\n            customWidgetTemplatePath = templatePath;\n            return this;\n        };\n\n        var widgets = {};\n        var widgetsPath = '';\n        var structures = {};\n        var messageTemplate = '<div class=\"alert alert-danger\">{}</div>';\n        var loadingTemplate = '\\\n      <div class=\"progress progress-striped active\">\\n\\\n        <div class=\"progress-bar\" role=\"progressbar\" style=\"width: 100%\">\\n\\\n          <span class=\"sr-only\">loading ...</span>\\n\\\n        </div>\\n\\\n      </div>';\n\n        /**\n         * @ngdoc method\n         * @name adf.dashboardProvider#widget\n         * @methodOf adf.dashboardProvider\n         * @description\n         *\n         * Registers a new widget.\n         *\n         * @param {string} name of the widget\n         * @param {object} widget to be registered.\n         *\n         *   Object properties:\n         *\n         *   - `title` - `{string=}` - The title of the widget.\n         *   - `description` - `{string=}` - Description of the widget.\n         *   - `config` - `{object}` - Predefined widget configuration.\n         *   - `controller` - `{string=|function()=}` - Controller fn that should be\n         *      associated with newly created scope of the widget or the name of a\n         *      {@link http://docs.angularjs.org/api/angular.Module#controller registered controller}\n         *      if passed as a string.\n         *   - `controllerAs` - `{string=}` - A controller alias name. If present the controller will be\n         *      published to scope under the `controllerAs` name.\n         *   - `template` - `{string=|function()=}` - html template as a string.\n         *   - `templateUrl` - `{string=}` - path to an html template.\n         *   - `reload` - `{boolean=}` - true if the widget could be reloaded. The default is false.\n         *   - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\n         *      be injected into the controller. If any of these dependencies are promises, the widget\n         *      will wait for them all to be resolved or one to be rejected before the controller is\n         *      instantiated.\n         *      If all the promises are resolved successfully, the values of the resolved promises are\n         *      injected.\n         *\n         *      The map object is:\n         *      - `key` – `{string}`: a name of a dependency to be injected into the controller.\n         *      - `factory` - `{string|function}`: If `string` then it is an alias for a service.\n         *        Otherwise if function, then it is {@link http://docs.angularjs.org/api/AUTO.$injector#invoke injected}\n         *        and the return value is treated as the dependency. If the result is a promise, it is\n         *        resolved before its value is injected into the controller.\n         *   - `edit` - `{object}` - Edit modus of the widget.\n         *      - `controller` - `{string=|function()=}` - Same as above, but for the edit mode of the widget.\n         *      - `template` - `{string=|function()=}` - Same as above, but for the edit mode of the widget.\n         *      - `templateUrl` - `{string=}` - Same as above, but for the edit mode of the widget.\n         *      - `resolve` - `{Object.<string, function>=}` - Same as above, but for the edit mode of the widget.\n         *      - `reload` - {boolean} - true if the widget should be reloaded, after the edit mode is closed.\n         *        Default is true.\n         *\n         * @returns {Object} self\n         */\n        this.widget = function (name, widget) {\n            var w = angular.extend({reload: false}, widget);\n            if (w.edit) {\n                var edit = {reload: true};\n                angular.extend(edit, w.edit);\n                w.edit = edit;\n            }\n            widgets[name] = w;\n            return this;\n        };\n\n        /**\n         * @ngdoc method\n         * @name adf.dashboardProvider#widgetsPath\n         * @methodOf adf.dashboardProvider\n         * @description\n         *\n         * Sets the path to the directory which contains the widgets. The widgets\n         * path is used for widgets with a templateUrl which contains the\n         * placeholder {widgetsPath}. The placeholder is replaced with the\n         * configured value, before the template is loaded, but the template is\n         * cached with the unmodified templateUrl (e.g.: {widgetPath}/src/widgets).\n         * The default value of widgetPaths is ''.\n         *\n         *\n         * @param {string} path to the directory which contains the widgets\n         *\n         * @returns {Object} self\n         */\n        this.widgetsPath = function (path) {\n            widgetsPath = path;\n            return this;\n        };\n\n        /**\n         * @ngdoc method\n         * @name adf.dashboardProvider#structure\n         * @methodOf adf.dashboardProvider\n         * @description\n         *\n         * Registers a new structure.\n         *\n         * @param {string} name of the structure\n         * @param {object} structure to be registered.\n         *\n         *   Object properties:\n         *\n         *   - `rows` - `{Array.<Object>}` - Rows of the dashboard structure.\n         *     - `styleClass` - `{string}` - CSS Class of the row.\n         *     - `columns` - `{Array.<Object>}` - Columns of the row.\n         *       - `styleClass` - `{string}` - CSS Class of the column.\n         *\n         * @returns {Object} self\n         */\n        this.structure = function (name, structure) {\n            structures[name] = structure;\n            return this;\n        };\n\n        /**\n         * @ngdoc method\n         * @name adf.dashboardProvider#messageTemplate\n         * @methodOf adf.dashboardProvider\n         * @description\n         *\n         * Changes the template for messages.\n         *\n         * @param {string} template for messages.\n         *\n         * @returns {Object} self\n         */\n        this.messageTemplate = function (template) {\n            messageTemplate = template;\n            return this;\n        };\n\n        /**\n         * @ngdoc method\n         * @name adf.dashboardProvider#loadingTemplate\n         * @methodOf adf.dashboardProvider\n         * @description\n         *\n         * Changes the template which is displayed as\n         * long as the widget resources are not resolved.\n         *\n         * @param {string} loading template\n         *\n         * @returns {Object} self\n         */\n        this.loadingTemplate = function (template) {\n            loadingTemplate = template;\n            return this;\n        };\n\n        /**\n         * @ngdoc service\n         * @name adf.dashboard\n         * @description\n         *\n         * The dashboard holds all options, structures and widgets.\n         *\n         * @property {Array.<Object>} widgets Array of registered widgets.\n         * @property {string} widgetsPath Default path for widgets.\n         * @property {Array.<Object>} structures Array of registered structures.\n         * @property {string} messageTemplate Template for messages.\n         * @property {string} loadingTemplate Template for widget loading.\n         *\n         * @returns {Object} self\n         */\n        this.$get = function () {\n            var cid = 0;\n\n            return {\n                widgets: widgets,\n                widgetsPath: widgetsPath,\n                structures: structures,\n                messageTemplate: messageTemplate,\n                loadingTemplate: loadingTemplate,\n                setLocale: this.setLocale,\n                locales: getLocales,\n                activeLocale: getActiveLocale,\n                translate: translate,\n                customWidgetTemplatePath: customWidgetTemplatePath,\n\n                /**\n                 * @ngdoc method\n                 * @name adf.dashboard#id\n                 * @methodOf adf.dashboard\n                 * @description\n                 *\n                 * Creates an ongoing numeric id. The method is used to create ids for\n                 * columns and widgets in the dashboard.\n                 */\n                id: function () {\n                    return ++cid;\n                }\n            };\n        };\n\n    }]);\n\n/*\n* The MIT License\n*\n* Copyright (c) 2015, Sebastian Sdorra\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in\n* all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\n\n/* global angular */\nangular.module('adf')\n    .directive('adfDashboardRow', [\"$compile\", \"adfTemplatePath\", \"columnTemplate\", function ($compile, adfTemplatePath, columnTemplate) {\n        \n\n        return {\n            restrict: 'E',\n            replace: true,\n            scope: {\n                row: '=',\n                adfModel: '=',\n                editMode: '=',\n                options: '='\n            },\n            templateUrl: adfTemplatePath + 'dashboard-row.html',\n            link: function ($scope, $element) {\n                if (angular.isDefined($scope.row.columns) && angular.isArray($scope.row.columns)) {\n                    $compile(columnTemplate)($scope, function (cloned) {\n                        $element.append(cloned);\n                    });\n                }\n            }\n        };\n    }]);\n\n/*\n * The MIT License\n *\n * Copyright (c) 2015, Sebastian Sdorra\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n\nangular.module('adf')\n    .directive('adfWidgetContent', [\"$log\", \"$q\", \"$sce\", \"$http\", \"$templateCache\", \"$compile\", \"$controller\", \"$injector\", \"dashboard\", function ($log, $q, $sce, $http, $templateCache,\n                                             $compile, $controller, $injector, dashboard) {\n\n        function parseUrl(url) {\n            var parsedUrl = url;\n            if (url.indexOf('{widgetsPath}') >= 0) {\n                parsedUrl = url.replace('{widgetsPath}', dashboard.widgetsPath)\n                    .replace('//', '/');\n                if (parsedUrl.indexOf('/') === 0) {\n                    parsedUrl = parsedUrl.substring(1);\n                }\n            }\n            return parsedUrl;\n        }\n\n        function getTemplate(widget) {\n            var deferred = $q.defer();\n\n            if (widget.template) {\n                deferred.resolve(widget.template);\n            } else if (widget.templateUrl) {\n                // try to fetch template from cache\n                var tpl = $templateCache.get(widget.templateUrl);\n                if (tpl) {\n                    deferred.resolve(tpl);\n                } else {\n                    var url = $sce.getTrustedResourceUrl(parseUrl(widget.templateUrl));\n                    //$http.get(url)\n                    //  .success(function(response){\n                    //    // put response to cache, with unmodified url as key\n                    //    $templateCache.put(widget.templateUrl, response);\n                    //    deferred.resolve(response);\n                    //  })\n                    //  .error(function(){\n                    //    deferred.reject('could not load template');\n                    //  });\n\n                    //jwu: above code not working\n                    $http.get(url).then(function (response) {\n                        // put response to cache, with unmodified url as key\n                        $templateCache.put(widget.templateUrl, response.data);\n                        deferred.resolve(response.data);\n                    }, (function () {\n                        deferred.reject('could not load template');\n                    }));\n                }\n            }\n\n            return deferred.promise;\n        }\n\n        function compileWidget($scope, $element, currentScope) {\n            var model = $scope.model;\n            var content = $scope.content;\n\n            // display loading template\n            $element.html(dashboard.loadingTemplate);\n\n            // create new scope\n            var templateScope = $scope.$new();\n\n            // pass config object to scope\n            if (!model.config) {\n                model.config = {};\n            }\n\n            templateScope.config = model.config;\n\n            // local injections\n            var base = {\n                $scope: templateScope,\n                widget: model,\n                config: model.config\n            };\n\n            // get resolve promises from content object\n            var resolvers = {};\n            resolvers.$tpl = getTemplate(content);\n            if (content.resolve) {\n                angular.forEach(content.resolve, function (promise, key) {\n                    if (angular.isString(promise)) {\n                        resolvers[key] = $injector.get(promise);\n                    } else {\n                        resolvers[key] = $injector.invoke(promise, promise, base);\n                    }\n                });\n            }\n\n            // resolve all resolvers\n            $q.all(resolvers).then(function (locals) {\n                angular.extend(locals, base);\n\n                // compile & render template\n                var template = locals.$tpl;\n                $element.html(template);\n                if (content.controller) {\n                    var templateCtrl = $controller(content.controller, locals);\n                    if (content.controllerAs) {\n                        templateScope[content.controllerAs] = templateCtrl;\n                    }\n                    $element.children().data('$ngControllerController', templateCtrl);\n                }\n                $compile($element.contents())(templateScope);\n            }, function (reason) {\n                // handle promise rejection\n                var msg = 'Could not resolve all promises';\n                if (reason) {\n                    msg += ': ' + reason;\n                }\n                $log.warn(msg);\n                $element.html(dashboard.messageTemplate.replace(/{}/g, msg));\n            });\n\n            // destroy old scope\n            if (currentScope) {\n                currentScope.$destroy();\n            }\n\n            return templateScope;\n        }\n\n        return {\n            replace: true,\n            restrict: 'EA',\n            transclude: false,\n            scope: {\n                model: '=',\n                content: '='\n            },\n            link: function ($scope, $element) {\n                var currentScope = compileWidget($scope, $element, null);\n                $scope.$on('widgetConfigChanged', function () {\n                    currentScope = compileWidget($scope, $element, currentScope);\n                });\n                $scope.$on('widgetReload', function () {\n                    currentScope = compileWidget($scope, $element, currentScope);\n                });\n            }\n        };\n\n    }]);\n\n/*\n * The MIT License\n *\n * Copyright (c) 2015, Sebastian Sdorra\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n\nangular.module('adf')\n    .directive('adfWidget', [\"$log\", \"$modal\", \"dashboard\", \"adfTemplatePath\", function ($log, $modal, dashboard, adfTemplatePath) {\n\n        function preLink($scope) {\n            var definition = $scope.definition;\n\n            //passs translate function from dashboard so we can translate labels inside html templates\n            $scope.translate = dashboard.translate;\n\n            if (definition) {\n                var w = dashboard.widgets[definition.type];\n                if (w) {\n                    // pass title\n                    if (!definition.title) {\n                        definition.title = w.title;\n                    }\n\n                    if (!definition.titleTemplateUrl) {\n                        definition.titleTemplateUrl = adfTemplatePath + 'widget-title.html';\n                        if (w.titleTemplateUrl) {\n                            definition.titleTemplateUrl = w.titleTemplateUrl;\n                        }\n                    }\n                    if (!definition.deleteTemplateUrl) {\n                        definition.deleteTemplateUrl = adfTemplatePath + 'widget-delete.html';\n                        if (w.deleteTemplateUrl) {\n                            definition.deleteTemplateUrl = w.deleteTemplateUrl;\n                        }\n                    }\n                    if (!definition.editTemplateUrl) {\n                        definition.editTemplateUrl = adfTemplatePath + 'widget-edit.html';\n                        if (w.editTemplateUrl) {\n                            definition.editTemplateUrl = w.editTemplateUrl;\n                        }\n                    }\n                    if (!definition.fullscreenTemplateUrl) {\n                        definition.fullscreenTemplateUrl = adfTemplatePath + 'widget-fullscreen.html';\n                        if (w.fullscreenTemplateUrl) {\n                            definition.fullscreenTemplateUrl = w.fullscreenTemplateUrl;\n                        }\n                    }\n\n\n                    // set id for sortable\n                    if (!definition.wid) {\n                        definition.wid = dashboard.id();\n                    }\n\n                    // pass copy of widget to scope\n                    $scope.widget = angular.copy(w);\n\n                    // create config object\n                    var config = definition.config;\n                    if (config) {\n                        if (angular.isString(config)) {\n                            config = angular.fromJson(config);\n                        }\n                    } else {\n                        config = {};\n                    }\n\n                    // pass config to scope\n                    $scope.config = config;\n\n                    // collapse exposed $scope.widgetState property\n                    if (!$scope.widgetState) {\n                        $scope.widgetState = {};\n                        $scope.widgetState.isCollapsed = false;\n                    }\n\n                } else {\n                    $log.warn('could not find widget ' + definition.type);\n                }\n            } else {\n                $log.debug('definition not specified, widget was probably removed');\n            }\n        }\n\n        function postLink($scope, $element) {\n            var definition = $scope.definition;\n            if (definition) {\n                // bind close function\n\n                var deleteWidget = function () {\n                    var column = $scope.col;\n                    if (column) {\n                        var index = column.widgets.indexOf(definition);\n                        if (index >= 0) {\n                            column.widgets.splice(index, 1);\n                        }\n                    }\n                    $element.remove();\n                };\n                $scope.remove = function () {\n                    if ($scope.options.enableConfirmDelete) {\n                        var deleteScope = $scope.$new();\n                        deleteScope.translate = dashboard.translate;\n\n                        var adfDeleteTemplatePath = (definition.deleteTemplateUrl) ? definition.deleteTemplateUrl\n                            : adfTemplatePath + 'widget-delete.html';\n\n                        var opts = {\n                            scope: deleteScope,\n                            templateUrl: adfDeleteTemplatePath,\n                            backdrop: 'static'\n                        };\n                        var instance = $modal.open(opts);\n\n                        deleteScope.closeDialog = function () {\n                            instance.close();\n                            deleteScope.$destroy();\n                        };\n                        deleteScope.deleteDialog = function () {\n                            deleteWidget();\n                            deleteScope.closeDialog();\n                        };\n                    }\n                    else {\n                        deleteWidget();\n                    }\n                };\n\n                // bind reload function\n                $scope.reload = function () {\n                    $scope.$broadcast('widgetReload');\n                };\n\n                // bind edit function\n                $scope.edit = function () {\n                    var editScope = $scope.$new();\n                    editScope.translate = dashboard.translate;\n                    editScope.definition = angular.copy(definition);\n\n                    var adfEditTemplatePath = (definition.editTemplateUrl) ? definition.editTemplateUrl\n                        : adfTemplatePath + 'widget-edit.html';\n\n                    var opts = {\n                        scope: editScope,\n                        templateUrl: adfEditTemplatePath,\n                        backdrop: 'static'\n                    };\n\n                    var instance = $modal.open(opts);\n                    editScope.closeDialog = function () {\n                        instance.close();\n                        editScope.$destroy();\n\n                        var widget = $scope.widget;\n                        if (widget.edit && widget.edit.reload) {\n                            // reload content after edit dialog is closed\n                            $scope.$broadcast('widgetConfigChanged');\n                        }\n                    };\n                    editScope.saveDialog = function () {\n                        definition.title = editScope.definition.title;\n                        angular.extend(definition.config, editScope.definition.config);\n                        editScope.closeDialog();\n                    };\n                };\n            } else {\n                $log.debug('widget not found');\n            }\n        }\n\n        return {\n            replace: true,\n            restrict: 'EA',\n            transclude: false,\n            templateUrl: dashboard.customWidgetTemplatePath ? dashboard.customWidgetTemplatePath : adfTemplatePath + 'widget.html',\n            scope: {\n                definition: '=',\n                col: '=column',\n                editMode: '=',\n                options: '=',\n                widgetState: '='\n            },\n\n            controller: [\"$scope\", function ($scope) {\n\n                $scope.$on(\"adfDashboardCollapseExapand\", function (event, args) {\n                    $scope.widgetState.isCollapsed = args.collapseExpandStatus;\n                });\n\n                $scope.openFullScreen = function () {\n                    var definition = $scope.definition;\n                    var fullScreenScope = $scope.$new();\n                    fullScreenScope.translate = dashboard.translate;\n\n                    var fullscreenTemplateUrl = (definition.fullscreenTemplateUrl) ? definition.fullscreenTemplateUrl\n                        : adfTemplatePath + 'widget-fullscreen.html';\n\n                    var opts = {\n                        scope: fullScreenScope,\n                        templateUrl: fullscreenTemplateUrl,\n                        size: definition.modalSize || 'lg', // 'sm', 'lg'\n                        backdrop: 'static',\n                        windowClass: (definition.fullScreen) ? 'dashboard-modal widget-fullscreen' : 'dashboard-modal'\n                    };\n\n                    var instance = $modal.open(opts);\n                    fullScreenScope.closeDialog = function () {\n                        instance.close();\n                        fullScreenScope.$destroy();\n                    };\n                };\n            }],\n\n            compile: function compile() {\n\n                /**\n                 * use pre link, because link of widget-content\n                 * is executed before post link widget\n                 */\n                return {\n                    pre: preLink,\n                    post: postLink\n                };\n            }\n        };\n\n    }]);\n\nangular.module(\"adf\").run([\"$templateCache\", function($templateCache) {$templateCache.put(\"../src/templates/dashboard-column.html\",\"<div adf-id={{column.cid}} class=column ng-class=column.styleClass ng-model=column.widgets> <adf-widget ng-repeat=\\\"definition in column.widgets\\\" definition=definition column=column edit-mode=editMode options=options widget-state=widgetState>  </adf-widget></div> \");\n$templateCache.put(\"../src/templates/dashboard-edit.html\",\"<div class=modal-header> <button type=button class=close ng-click=closeDialog() aria-hidden=true>&times;</button> <h4 class=modal-title ng-bind=\\\"translate(\\'ADF_COMMON_EDIT_DASHBOARD\\')\\\">Edit Dashboard</h4> </div> <div class=modal-body> <form role=form> <div class=form-group> <label for=dashboardTitle ng-bind=\\\"translate(\\'ADF_COMMON_TITLE\\')\\\">Title</label> <input type=text class=form-control id=dashboardTitle ng-model=copy.title required> </div> <div class=form-group> <label ng-bind=\\\"translate(\\'ADF_EDIT_DASHBOARD_STRUCTURE_LABEL\\')\\\">Structure</label> <div class=radio ng-repeat=\\\"(key, structure) in structures\\\"> <label> <input type=radio value={{key}} ng-model=model.structure ng-change=\\\"changeStructure(key, structure)\\\"> {{key}} </label> </div> </div> </form> </div> <div class=modal-footer> <button type=button class=\\\"btn btn-primary\\\" ng-click=closeDialog() ng-bind=\\\"translate(\\'ADF_COMMON_CLOSE\\')\\\">Close</button> </div> \");\n$templateCache.put(\"../src/templates/dashboard-row.html\",\"<div class=row ng-class=row.styleClass>  </div> \");\n$templateCache.put(\"../src/templates/dashboard-title.html\",\"<h1> {{model.title}} <span style=\\\"font-size: 16px\\\" class=pull-right> <a href ng-if=editMode title=\\\"{{ translate(\\'ADF_DASHBOARD_TITLE_TOOLTIP_ADD\\') }}\\\" ng-click=addWidgetDialog()> <i class=\\\"glyphicon glyphicon-plus-sign\\\"></i> </a> <a href ng-if=editMode title=\\\"{{ translate(\\'ADF_COMMON_EDIT_DASHBOARD\\') }}\\\" ng-click=editDashboardDialog()> <i class=\\\"glyphicon glyphicon-cog\\\"></i> </a> <a href ng-if=options.editable title=\\\"{{editMode ? translate(\\'ADF_DASHBOARD_TITLE_TOOLTIP_SAVE\\') : translate(\\'ADF_DASHBOARD_TITLE_TOOLTIP_EDIT_MODE\\') }}\\\" ng-click=toggleEditMode()> <i class=glyphicon x-ng-class=\\\"{\\'glyphicon-edit\\' : !editMode, \\'glyphicon-save\\' : editMode}\\\"></i> </a> <a href ng-if=editMode title=\\\"{{ translate(\\'ADF_DASHBOARD_TITLE_TOOLTIP_UNDO\\') }}\\\" ng-click=cancelEditMode()> <i class=\\\"glyphicon glyphicon-repeat adf-flip\\\"></i> </a> </span> </h1> \");\n$templateCache.put(\"../src/templates/dashboard.html\",\"<div class=dashboard-container> <div ng-include src=model.titleTemplateUrl></div> <div class=dashboard x-ng-class=\\\"{\\'edit\\' : editMode}\\\"> <adf-dashboard-row row=row adf-model=model options=options ng-repeat=\\\"row in model.rows\\\" edit-mode=editMode> </adf-dashboard-row></div> </div> \");\n$templateCache.put(\"../src/templates/widget-add.html\",\"<div class=modal-header> <button type=button class=close ng-click=closeDialog() aria-hidden=true>&times;</button> <h4 class=modal-title ng-bind=\\\"translate(\\'ADF_WIDGET_ADD_HEADER\\')\\\">Add new widget</h4> </div> <div class=modal-body> <div style=\\\"display: inline-block;\\\"> <dl class=dl-horizontal> <dt ng-repeat-start=\\\"(key, widget) in widgets\\\"> <a href ng-click=addWidget(key)> {{widget.title}} </a> </dt> <dd ng-repeat-end ng-if=widget.description> {{widget.description}} </dd> </dl> </div> </div> <div class=modal-footer> <button type=button class=\\\"btn btn-primary\\\" ng-click=closeDialog() ng-bind=\\\"translate(\\'ADF_COMMON_CLOSE\\')\\\">Close</button> </div> \");\n$templateCache.put(\"../src/templates/widget-delete.html\",\"<div class=modal-header> <h4 class=modal-title><span ng-bind=\\\"translate(\\'ADF_COMMON_DELETE\\')\\\">Delete</span> {{widget.title}}</h4> </div> <div class=modal-body> <form role=form> <div class=form-group> <label for=widgetTitle ng-bind=\\\"translate(\\'ADF_WIDGET_DELETE_CONFIRM_MESSAGE\\')\\\">Are you sure you want to delete this widget ?</label> </div> </form> </div> <div class=modal-footer> <button type=button class=\\\"btn btn-default\\\" ng-click=closeDialog() ng-bind=\\\"translate(\\'ADF_COMMON_CLOSE\\')\\\">Close</button> <button type=button class=\\\"btn btn-primary\\\" ng-click=deleteDialog() ng-bind=\\\"translate(\\'ADF_COMMON_DELETE\\')\\\">Delete</button> </div> \");\n$templateCache.put(\"../src/templates/widget-edit.html\",\"<div class=modal-header> <button type=button class=close ng-click=closeDialog() aria-hidden=true>&times;</button> <h4 class=modal-title>{{widget.title}}</h4> </div> <div class=modal-body> <form role=form> <div class=form-group> <label for=widgetTitle ng-bind=\\\"translate(\\'ADF_COMMON_TITLE\\')\\\">Title</label> <input type=text class=form-control id=widgetTitle ng-model=definition.title placeholder=\\\"Enter title\\\" required> </div> </form> <div ng-if=widget.edit> <adf-widget-content model=definition content=widget.edit> </adf-widget-content></div> </div> <div class=modal-footer> <button type=button class=\\\"btn btn-default\\\" ng-click=closeDialog() ng-bind=\\\"translate(\\'ADF_COMMON_CANCEL\\')\\\">Cancel</button> <button type=button class=\\\"btn btn-primary\\\" ng-click=saveDialog() ng-bind=\\\"translate(\\'ADF_COMMON_APPLY\\')\\\">Apply</button> </div> \");\n$templateCache.put(\"../src/templates/widget-fullscreen.html\",\"<div class=modal-header> <div class=\\\"pull-right widget-icons\\\"> <a href title=\\\"Reload Widget Content\\\" ng-if=widget.reload ng-click=reload()> <i class=\\\"glyphicon glyphicon-refresh\\\"></i> </a> <a href title=close ng-click=closeDialog()> <i class=\\\"glyphicon glyphicon-remove\\\"></i> </a> </div> <h4 class=modal-title>{{definition.title}}</h4> </div> <div class=modal-body> <adf-widget-content model=definition content=widget> </adf-widget-content></div> <div class=modal-footer> <button type=button class=\\\"btn btn-primary\\\" ng-click=closeDialog()>Close</button> </div> \");\n$templateCache.put(\"../src/templates/widget-title.html\",\"<h3 class=panel-title> {{definition.title}} <span class=pull-right> <a href title=\\\"{{ translate(\\'ADF_WIDGET_TOOLTIP_REFRESH\\') }}\\\" ng-if=widget.reload ng-click=reload()> <i class=\\\"glyphicon glyphicon-refresh\\\"></i> </a>  <a href title=\\\"{{ translate(\\'ADF_WIDGET_TOOLTIP_MOVE\\') }}\\\" class=adf-move ng-if=editMode> <i class=\\\"glyphicon glyphicon-move\\\"></i> </a>  <a href title=\\\"{{ translate(\\'ADF_WIDGET_TOOLTIP_COLLAPSE\\') }}\\\" ng-show=\\\"options.collapsible && !widgetState.isCollapsed\\\" ng-click=\\\"widgetState.isCollapsed = !widgetState.isCollapsed\\\"> <i class=\\\"glyphicon glyphicon-minus\\\"></i> </a>  <a href title=\\\"{{ translate(\\'ADF_WIDGET_TOOLTIP_EXPAND\\') }}\\\" ng-show=\\\"options.collapsible && widgetState.isCollapsed\\\" ng-click=\\\"widgetState.isCollapsed = !widgetState.isCollapsed\\\"> <i class=\\\"glyphicon glyphicon-plus\\\"></i> </a>  <a href title=\\\"{{ translate(\\'ADF_WIDGET_TOOLTIP_EDIT\\') }}\\\" ng-click=edit() ng-if=editMode> <i class=\\\"glyphicon glyphicon-cog\\\"></i> </a> <a href title=\\\"{{ translate(\\'ADF_WIDGET_TOOLTIP_FULLSCREEN\\') }}\\\" ng-click=openFullScreen() ng-show=options.maximizable> <i class=\\\"glyphicon glyphicon-fullscreen\\\"></i> </a>  <a href title=\\\"{{ translate(\\'ADF_WIDGET_TOOLTIP_REMOVE\\') }}\\\" ng-click=remove() ng-if=editMode> <i class=\\\"glyphicon glyphicon-remove\\\"></i> </a> </span> </h3> \");\n$templateCache.put(\"../src/templates/widget.html\",\"<div adf-id={{definition.wid}} adf-widget-type={{definition.type}} class=\\\"widget panel panel-default\\\"> <div class=\\\"panel-heading clearfix\\\"> <div ng-include src=definition.titleTemplateUrl></div> </div> <div class=panel-body collapse=widgetState.isCollapsed> <adf-widget-content model=definition content=widget> </adf-widget-content></div> </div> \");}]);})(window);","/*\n * The MIT License\n *\n * Copyright (c) 2015, Sebastian Sdorra\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n'use strict';\n\nangular.module('adf')\n    .directive('adfWidget', function ($log, $modal, dashboard, adfTemplatePath) {\n\n        function preLink($scope) {\n            var definition = $scope.definition;\n\n            //passs translate function from dashboard so we can translate labels inside html templates\n            $scope.translate = dashboard.translate;\n\n            if (definition) {\n                var w = dashboard.widgets[definition.type];\n                if (w) {\n                    // pass title\n                    if (!definition.title) {\n                        definition.title = w.title;\n                    }\n\n                    if (!definition.titleTemplateUrl) {\n                        definition.titleTemplateUrl = adfTemplatePath + 'widget-title.html';\n                        if (w.titleTemplateUrl) {\n                            definition.titleTemplateUrl = w.titleTemplateUrl;\n                        }\n                    }\n                    if (!definition.deleteTemplateUrl) {\n                        definition.deleteTemplateUrl = adfTemplatePath + 'widget-delete.html';\n                        if (w.deleteTemplateUrl) {\n                            definition.deleteTemplateUrl = w.deleteTemplateUrl;\n                        }\n                    }\n                    if (!definition.editTemplateUrl) {\n                        definition.editTemplateUrl = adfTemplatePath + 'widget-edit.html';\n                        if (w.editTemplateUrl) {\n                            definition.editTemplateUrl = w.editTemplateUrl;\n                        }\n                    }\n                    if (!definition.fullscreenTemplateUrl) {\n                        definition.fullscreenTemplateUrl = adfTemplatePath + 'widget-fullscreen.html';\n                        if (w.fullscreenTemplateUrl) {\n                            definition.fullscreenTemplateUrl = w.fullscreenTemplateUrl;\n                        }\n                    }\n\n\n                    // set id for sortable\n                    if (!definition.wid) {\n                        definition.wid = dashboard.id();\n                    }\n\n                    // pass copy of widget to scope\n                    $scope.widget = angular.copy(w);\n\n                    // create config object\n                    var config = definition.config;\n                    if (config) {\n                        if (angular.isString(config)) {\n                            config = angular.fromJson(config);\n                        }\n                    } else {\n                        config = {};\n                    }\n\n                    // pass config to scope\n                    $scope.config = config;\n\n                    // collapse exposed $scope.widgetState property\n                    if (!$scope.widgetState) {\n                        $scope.widgetState = {};\n                        $scope.widgetState.isCollapsed = false;\n                    }\n\n                } else {\n                    $log.warn('could not find widget ' + definition.type);\n                }\n            } else {\n                $log.debug('definition not specified, widget was probably removed');\n            }\n        }\n\n        function postLink($scope, $element) {\n            var definition = $scope.definition;\n            if (definition) {\n                // bind close function\n\n                var deleteWidget = function () {\n                    var column = $scope.col;\n                    if (column) {\n                        var index = column.widgets.indexOf(definition);\n                        if (index >= 0) {\n                            column.widgets.splice(index, 1);\n                        }\n                    }\n                    $element.remove();\n                };\n                $scope.remove = function () {\n                    if ($scope.options.enableConfirmDelete) {\n                        var deleteScope = $scope.$new();\n                        deleteScope.translate = dashboard.translate;\n\n                        var adfDeleteTemplatePath = (definition.deleteTemplateUrl) ? definition.deleteTemplateUrl\n                            : adfTemplatePath + 'widget-delete.html';\n\n                        var opts = {\n                            scope: deleteScope,\n                            templateUrl: adfDeleteTemplatePath,\n                            backdrop: 'static'\n                        };\n                        var instance = $modal.open(opts);\n\n                        deleteScope.closeDialog = function () {\n                            instance.close();\n                            deleteScope.$destroy();\n                        };\n                        deleteScope.deleteDialog = function () {\n                            deleteWidget();\n                            deleteScope.closeDialog();\n                        };\n                    }\n                    else {\n                        deleteWidget();\n                    }\n                };\n\n                // bind reload function\n                $scope.reload = function () {\n                    $scope.$broadcast('widgetReload');\n                };\n\n                // bind edit function\n                $scope.edit = function () {\n                    var editScope = $scope.$new();\n                    editScope.translate = dashboard.translate;\n                    editScope.definition = angular.copy(definition);\n\n                    var adfEditTemplatePath = (definition.editTemplateUrl) ? definition.editTemplateUrl\n                        : adfTemplatePath + 'widget-edit.html';\n\n                    var opts = {\n                        scope: editScope,\n                        templateUrl: adfEditTemplatePath,\n                        backdrop: 'static'\n                    };\n\n                    var instance = $modal.open(opts);\n                    editScope.closeDialog = function () {\n                        instance.close();\n                        editScope.$destroy();\n\n                        var widget = $scope.widget;\n                        if (widget.edit && widget.edit.reload) {\n                            // reload content after edit dialog is closed\n                            $scope.$broadcast('widgetConfigChanged');\n                        }\n                    };\n                    editScope.saveDialog = function () {\n                        definition.title = editScope.definition.title;\n                        angular.extend(definition.config, editScope.definition.config);\n                        editScope.closeDialog();\n                    };\n                };\n            } else {\n                $log.debug('widget not found');\n            }\n        }\n\n        return {\n            replace: true,\n            restrict: 'EA',\n            transclude: false,\n            templateUrl: dashboard.customWidgetTemplatePath ? dashboard.customWidgetTemplatePath : adfTemplatePath + 'widget.html',\n            scope: {\n                definition: '=',\n                col: '=column',\n                editMode: '=',\n                options: '=',\n                widgetState: '='\n            },\n\n            controller: function ($scope) {\n\n                $scope.$on(\"adfDashboardCollapseExapand\", function (event, args) {\n                    $scope.widgetState.isCollapsed = args.collapseExpandStatus;\n                });\n\n                $scope.openFullScreen = function () {\n                    var definition = $scope.definition;\n                    var fullScreenScope = $scope.$new();\n                    fullScreenScope.translate = dashboard.translate;\n\n                    var fullscreenTemplateUrl = (definition.fullscreenTemplateUrl) ? definition.fullscreenTemplateUrl\n                        : adfTemplatePath + 'widget-fullscreen.html';\n\n                    var opts = {\n                        scope: fullScreenScope,\n                        templateUrl: fullscreenTemplateUrl,\n                        size: definition.modalSize || 'lg', // 'sm', 'lg'\n                        backdrop: 'static',\n                        windowClass: (definition.fullScreen) ? 'dashboard-modal widget-fullscreen' : 'dashboard-modal'\n                    };\n\n                    var instance = $modal.open(opts);\n                    fullScreenScope.closeDialog = function () {\n                        instance.close();\n                        fullScreenScope.$destroy();\n                    };\n                };\n            },\n\n            compile: function compile() {\n\n                /**\n                 * use pre link, because link of widget-content\n                 * is executed before post link widget\n                 */\n                return {\n                    pre: preLink,\n                    post: postLink\n                };\n            }\n        };\n\n    });\n",null,"(function(window, undefined) {'use strict';\n/*\n * The MIT License\n *\n * Copyright (c) 2015, Sebastian Sdorra\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n\nangular.module('adf', ['adf.provider', 'ui.bootstrap'])\n    .value('adfTemplatePath', '../src/templates/')\n    .value('rowTemplate', '<adf-dashboard-row row=\"row\" adf-model=\"adfModel\" options=\"options\" edit-mode=\"editMode\" ng-repeat=\"row in column.rows\" />')\n    .value('columnTemplate', '<adf-dashboard-column column=\"column\" adf-model=\"adfModel\" options=\"options\" edit-mode=\"editMode\" ng-repeat=\"column in row.columns\" />')\n    .value('adfVersion', '0.10.1.1');\n\n/*\n* The MIT License\n*\n* Copyright (c) 2015, Sebastian Sdorra\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in\n* all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\n\n\n/**\n * @ngdoc object\n * @name adf.locale#adfLocale\n * @description\n *\n * Holds settings and values for framework supported locales\n */\nangular.module('adf.locale', [])\n    .constant('adfLocale',\n        {\n            defaultLocale: 'en-GB',\n            frameworkLocales: {\n                'en-GB': {\n                    ADF_COMMON_CLOSE: 'Close',\n                    ADF_COMMON_DELETE: 'Delete',\n                    ADF_COMMON_TITLE: 'Title',\n                    ADF_COMMON_CANCEL: 'Cancel',\n                    ADF_COMMON_APPLY: 'Apply',\n                    ADF_COMMON_EDIT_DASHBOARD: 'Edit dashboard',\n                    ADF_EDIT_DASHBOARD_STRUCTURE_LABEL: 'Structure',\n                    ADF_DASHBOARD_TITLE_TOOLTIP_ADD: 'Add new widget',\n                    ADF_DASHBOARD_TITLE_TOOLTIP_SAVE: 'Save changes',\n                    ADF_DASHBOARD_TITLE_TOOLTIP_EDIT_MODE: 'Enable edit mode',\n                    ADF_DASHBOARD_TITLE_TOOLTIP_UNDO: 'Undo changes',\n                    ADF_WIDGET_ADD_HEADER: 'Add new widget',\n                    ADF_WIDGET_DELETE_CONFIRM_MESSAGE: 'Are you sure you want to delete this widget ?',\n                    ADF_WIDGET_TOOLTIP_REFRESH: 'Reload widget Content',\n                    ADF_WIDGET_TOOLTIP_MOVE: 'Change widget location',\n                    ADF_WIDGET_TOOLTIP_COLLAPSE: 'Collapse widget',\n                    ADF_WIDGET_TOOLTIP_EXPAND: 'Expand widget',\n                    ADF_WIDGET_TOOLTIP_EDIT: 'Edit widget configuration',\n                    ADF_WIDGET_TOOLTIP_FULLSCREEN: 'Fullscreen widget',\n                    ADF_WIDGET_TOOLTIP_REMOVE: 'Remove widget'\n                },\n                'sv-SE': {\n                    ADF_COMMON_CLOSE: 'Stäng',\n                    ADF_COMMON_DELETE: 'Ta bort',\n                    ADF_COMMON_TITLE: 'Titel',\n                    ADF_COMMON_CANCEL: 'Avbryt',\n                    ADF_COMMON_APPLY: 'Använd',\n                    ADF_COMMON_EDIT_DASHBOARD: 'Redigera dashboard',\n                    ADF_EDIT_DASHBOARD_STRUCTURE_LABEL: 'Struktur',\n                    ADF_DASHBOARD_TITLE_TOOLTIP_ADD: 'Lägg till ny widget',\n                    ADF_DASHBOARD_TITLE_TOOLTIP_SAVE: 'Spara förändringar',\n                    ADF_DASHBOARD_TITLE_TOOLTIP_EDIT_MODE: 'Slå på redigeringsläge',\n                    ADF_DASHBOARD_TITLE_TOOLTIP_UNDO: 'Ångra förändringar',\n                    ADF_WIDGET_ADD_HEADER: 'Lägg till ny widget',\n                    ADF_WIDGET_DELETE_CONFIRM_MESSAGE: 'Är du säker på att du vill ta bort denna widget ?',\n                    ADF_WIDGET_TOOLTIP_REFRESH: 'Ladda om widget',\n                    ADF_WIDGET_TOOLTIP_MOVE: 'Ändra widgets position',\n                    ADF_WIDGET_TOOLTIP_COLLAPSE: 'Stäng widget',\n                    ADF_WIDGET_TOOLTIP_EXPAND: 'Öppna widget',\n                    ADF_WIDGET_TOOLTIP_EDIT: 'Ändra widget konfigurering',\n                    ADF_WIDGET_TOOLTIP_FULLSCREEN: 'Visa widget i fullskärm',\n                    ADF_WIDGET_TOOLTIP_REMOVE: 'Ta bort widget'\n                }\n            }\n        }\n    );\n\n\n/*\n* The MIT License\n*\n* Copyright (c) 2015, Sebastian Sdorra\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in\n* all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\n\n/* global angular */\nangular.module('adf')\n    .directive('adfDashboardColumn', function ($log, $compile, adfTemplatePath, rowTemplate, dashboard) {\n        \n\n        /**\n         * moves a widget in between a column\n         */\n        function moveWidgetInColumn($scope, column, evt) {\n            var widgets = column.widgets;\n            // move widget and apply to scope\n            $scope.$apply(function () {\n                widgets.splice(evt.newIndex, 0, widgets.splice(evt.oldIndex, 1)[0]);\n            });\n        }\n\n        /**\n         * finds a widget by its id in the column\n         */\n        function findWidget(column, index) {\n            var widget = null;\n            for (var i = 0; i < column.widgets.length; i++) {\n                var w = column.widgets[i];\n                if (w.wid === index) {\n                    widget = w;\n                    break;\n                }\n            }\n            return widget;\n        }\n\n        /**\n         * finds a column by its id in the model\n         */\n        function findColumn(model, index) {\n            var column = null;\n            for (var i = 0; i < model.rows.length; i++) {\n                var r = model.rows[i];\n                for (var j = 0; j < r.columns.length; j++) {\n                    var c = r.columns[j];\n                    if (c.cid === index) {\n                        column = c;\n                        break;\n                    } else if (c.rows) {\n                        column = findColumn(c, index);\n                    }\n                }\n                if (column) {\n                    break;\n                }\n            }\n            return column;\n        }\n\n        /**\n         * get the adf id from an html element\n         */\n        function getId(el) {\n            var id = el.getAttribute('adf-id');\n            return id ? parseInt(id) : -1;\n        }\n\n        /**\n         * adds a widget to a column\n         */\n        function addWidgetToColumn($scope, model, targetColumn, evt) {\n            // find source column\n            var cid = getId(evt.from);\n            var sourceColumn = findColumn(model, cid);\n\n            if (sourceColumn) {\n                // find moved widget\n                var wid = getId(evt.item);\n                var widget = findWidget(sourceColumn, wid);\n\n                if (widget) {\n                    // add new item and apply to scope\n                    $scope.$apply(function () {\n                        if (!targetColumn.widgets) {\n                            targetColumn.widgets = [];\n                        }\n\n                        targetColumn.widgets.splice(evt.newIndex, 0, widget);\n                    });\n                } else {\n                    $log.warn('could not find widget with id ' + wid);\n                }\n            } else {\n                $log.warn('could not find column with id ' + cid);\n            }\n        }\n\n        /**\n         * removes a widget from a column\n         */\n        function removeWidgetFromColumn($scope, column, evt) {\n            // remove old item and apply to scope\n            $scope.$apply(function () {\n                column.widgets.splice(evt.oldIndex, 1);\n            });\n        }\n\n        /**\n         * enable sortable\n         */\n        function applySortable($scope, $element, model, column) {\n            // enable drag and drop\n            var el = $element[0];\n            var sortable = Sortable.create(el, {\n                group: 'widgets',\n                handle: '.adf-move',\n                ghostClass: 'placeholder',\n                animation: 150,\n                onAdd: function (evt) {\n                    addWidgetToColumn($scope, model, column, evt);\n                },\n                onRemove: function (evt) {\n                    removeWidgetFromColumn($scope, column, evt);\n                },\n                onUpdate: function (evt) {\n                    moveWidgetInColumn($scope, column, evt);\n                }\n            });\n\n            // destroy sortable on column destroy event\n            $element.on('$destroy', function () {\n                sortable.destroy();\n            });\n        }\n\n        return {\n            restrict: 'E',\n            replace: true,\n            scope: {\n                column: '=',\n                editMode: '=',\n                adfModel: '=',\n                options: '='\n            },\n            templateUrl: adfTemplatePath + 'dashboard-column.html',\n            link: function ($scope, $element) {\n                // set id\n                var col = $scope.column;\n                if (!col.cid) {\n                    col.cid = dashboard.id();\n                }\n\n                if (angular.isDefined(col.rows) && angular.isArray(col.rows)) {\n                    // be sure to tell Angular about the injected directive and push the new row directive to the column\n                    $compile(rowTemplate)($scope, function (cloned) {\n                        $element.append(cloned);\n                    });\n                } else {\n                    // enable drag and drop for widget only columns\n                    applySortable($scope, $element, $scope.adfModel, col);\n                }\n            }\n        };\n    });\n\n/*\n * The MIT License\n *\n * Copyright (c) 2015, Sebastian Sdorra\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n/**\n * @ngdoc directive\n * @name adf.directive:adfDashboard\n * @element div\n * @restrict EA\n * @scope\n * @description\n *\n * `adfDashboard` is a directive which renders the dashboard with all its\n * components. The directive requires a name attribute. The name of the\n * dashboard can be used to store the model.\n *\n * @param {string} name name of the dashboard. This attribute is required.\n * @param {boolean=} editable false to disable the editmode of the dashboard.\n * @param {boolean=} collapsible true to make widgets collapsible on the dashboard.\n * @param {boolean=} maximizable true to add a button for open widgets in a large modal panel.\n * @param {boolean=} enableConfirmDelete true to ask before remove an widget from the dashboard.\n * @param {string=} structure the default structure of the dashboard.\n * @param {object=} adfModel model object of the dashboard.\n * @param {function=} adfWidgetFilter function to filter widgets on the add dialog.\n */\n\nangular.module('adf')\n    .directive('adfDashboard', function ($rootScope, $log, $modal, dashboard, adfTemplatePath) {\n        \n\n        function stringToBoolean(string) {\n            switch (angular.isDefined(string) ? string.toLowerCase() : null) {\n                case 'true':\n                case 'yes':\n                case '1':\n                    return true;\n                case 'false':\n                case 'no':\n                case '0':\n                case null:\n                    return false;\n                default:\n                    return Boolean(string);\n            }\n        }\n\n        function copyWidgets(source, target) {\n            if (source.widgets && source.widgets.length > 0) {\n                var w = source.widgets.shift();\n                while (w) {\n                    target.widgets.push(w);\n                    w = source.widgets.shift();\n                }\n            }\n        }\n\n        /**\n         * Copy widget from old columns to the new model\n         * @param object root the model\n         * @param array of columns\n         * @param counter\n         */\n        function fillStructure(root, columns, counter) {\n            counter = counter || 0;\n\n            if (angular.isDefined(root.rows)) {\n                angular.forEach(root.rows, function (row) {\n                    angular.forEach(row.columns, function (column) {\n                        // if the widgets prop doesn't exist, create a new array for it.\n                        // this allows ui.sortable to do it's thing without error\n                        if (!column.widgets) {\n                            column.widgets = [];\n                        }\n\n                        // if a column exist at the counter index, copy over the column\n                        if (angular.isDefined(columns[counter])) {\n                            // do not add widgets to a column, which uses nested rows\n                            if (!angular.isDefined(column.rows)) {\n                                copyWidgets(columns[counter], column);\n                                counter++;\n                            }\n                        }\n\n                        // run fillStructure again for any sub rows/columns\n                        counter = fillStructure(column, columns, counter);\n                    });\n                });\n            }\n            return counter;\n        }\n\n        /**\n         * Read Columns: recursively searches an object for the 'columns' property\n         * @param object model\n         * @param array  an array of existing columns; used when recursion happens\n         */\n        function readColumns(root, columns) {\n            columns = columns || [];\n\n            if (angular.isDefined(root.rows)) {\n                angular.forEach(root.rows, function (row) {\n                    angular.forEach(row.columns, function (col) {\n                        columns.push(col);\n                        // keep reading columns until we can't any more\n                        readColumns(col, columns);\n                    });\n                });\n            }\n\n            return columns;\n        }\n\n        function changeStructure(model, structure) {\n            var columns = readColumns(model);\n            var counter = 0;\n\n            model.rows = angular.copy(structure.rows);\n\n            while (counter < columns.length) {\n                counter = fillStructure(model, columns, counter);\n            }\n        }\n\n        function createConfiguration(type) {\n            var cfg = {};\n            var config = dashboard.widgets[type].config;\n            if (config) {\n                cfg = angular.copy(config);\n            }\n            return cfg;\n        }\n\n        /**\n         * Find first widget column in model.\n         *\n         * @param dashboard model\n         */\n        function findFirstWidgetColumn(model) {\n            var column = null;\n            if (!angular.isArray(model.rows)) {\n                $log.error('model does not have any rows');\n                return null;\n            }\n            for (var i = 0; i < model.rows.length; i++) {\n                var row = model.rows[i];\n                if (angular.isArray(row.columns)) {\n                    for (var j = 0; j < row.columns.length; j++) {\n                        var col = row.columns[j];\n                        if (!col.rows) {\n                            column = col;\n                            break;\n                        }\n                    }\n                }\n                if (column) {\n                    break;\n                }\n            }\n            return column;\n        }\n\n        /**\n         * Adds the widget to first column of the model.\n         *\n         * @param dashboard model\n         * @param widget to add to model\n         */\n        function addNewWidgetToModel(model, widget) {\n            if (model) {\n                var column = findFirstWidgetColumn(model);\n                if (column) {\n                    if (!column.widgets) {\n                        column.widgets = [];\n                    }\n                    column.widgets.unshift(widget);\n                } else {\n                    $log.error('could not find first widget column');\n                }\n            } else {\n                $log.error('model is undefined');\n            }\n        }\n\n        return {\n            replace: true,\n            restrict: 'EA',\n            transclude: false,\n            scope: {\n                structure: '@',\n                name: '@',\n                collapsible: '@',\n                editable: '@',\n                maximizable: '@',\n                adfModel: '=',\n                adfWidgetFilter: '='\n            },\n            controller: function ($scope) {\n                var model = {};\n                var structure = {};\n                var widgetFilter = null;\n                var structureName = {};\n                var name = $scope.name;\n\n                // Watching for changes on adfModel\n                $scope.$watch('adfModel', function (oldVal, newVal) {\n                    // has model changed or is the model attribute not set\n                    if (newVal !== null || (oldVal === null && newVal === null)) {\n                        model = $scope.adfModel;\n                        widgetFilter = $scope.adfWidgetFilter;\n                        if (!model || !model.rows) {\n                            structureName = $scope.structure;\n                            structure = dashboard.structures[structureName];\n                            if (structure) {\n                                if (model) {\n                                    model.rows = angular.copy(structure).rows;\n                                } else {\n                                    model = angular.copy(structure);\n                                }\n                                model.structure = structureName;\n                            } else {\n                                $log.error('could not find structure ' + structureName);\n                            }\n                        }\n\n                        if (model) {\n                            if (!model.title) {\n                                model.title = 'Dashboard';\n                            }\n                            if (!model.titleTemplateUrl) {\n                                model.titleTemplateUrl = adfTemplatePath + 'dashboard-title.html';\n                            }\n                            $scope.model = model;\n                        } else {\n                            $log.error('could not find or create model');\n                        }\n                    }\n                }, true);\n\n                // edit mode\n                $scope.editMode = false;\n                $scope.editClass = '';\n\n                $scope.translate = dashboard.translate;\n                var activeLocale = dashboard.activeLocale();\n                if (activeLocale) {\n                    dashboard.setLocale(activeLocale);\n                }\n\n                $scope.toggleEditMode = function () {\n                    $scope.editMode = !$scope.editMode;\n                    if ($scope.editMode) {\n                        $scope.modelCopy = angular.copy($scope.adfModel, {});\n                        $rootScope.$broadcast('adfDashboardEditMode', name, model);\n                    }\n\n                    if (!$scope.editMode) {\n                        $rootScope.$broadcast('adfDashboardChanged', name, model);\n                    }\n                };\n\n                $scope.$on('adfDashboardRetrieveChangedModel', function () {\n                    $rootScope.$broadcast('adfDashboardChanged', name, model);\n                });\n\n                $scope.collapseAll = function (collapseExpandStatus) {\n                    $rootScope.$broadcast('adfDashboardCollapseExapand', {collapseExpandStatus: collapseExpandStatus});\n                };\n\n                $scope.cancelEditMode = function () {\n                    $scope.editMode = false;\n                    $scope.modelCopy = angular.copy($scope.modelCopy, $scope.adfModel);\n                    $rootScope.$broadcast('adfDashboardEditsCancelled');\n                };\n\n                // edit dashboard settings\n                $scope.editDashboardDialog = function () {\n                    var editDashboardScope = $scope.$new();\n                    // create a copy of the title, to avoid changing the title to\n                    // \"dashboard\" if the field is empty\n                    editDashboardScope.copy = {\n                        title: model.title\n                    };\n                    editDashboardScope.structures = dashboard.structures;\n\n                    var adfEditTemplatePath = adfTemplatePath + 'dashboard-edit.html';\n                    if (model.editTemplateUrl) {\n                        adfEditTemplatePath = model.editTemplateUrl;\n                    }\n                    var instance = $modal.open({\n                        scope: editDashboardScope,\n                        templateUrl: adfEditTemplatePath,\n                        backdrop: 'static'\n                    });\n                    $scope.changeStructure = function (name, structure) {\n                        $log.info('change structure to ' + name);\n                        changeStructure(model, structure);\n                    };\n                    editDashboardScope.closeDialog = function () {\n                        // copy the new title back to the model\n                        model.title = editDashboardScope.copy.title;\n                        // close modal and destroy the scope\n                        instance.close();\n                        editDashboardScope.$destroy();\n                    };\n                };\n\n                // add widget dialog\n                $scope.addWidgetDialog = function () {\n                    var addScope = $scope.$new();\n                    var model = $scope.model;\n                    var widgets;\n                    if (angular.isFunction(widgetFilter)) {\n                        widgets = {};\n                        angular.forEach(dashboard.widgets, function (widget, type) {\n                            if (widgetFilter(widget, type, model)) {\n                                widgets[type] = widget;\n                            }\n                        });\n                    } else {\n                        widgets = dashboard.widgets;\n                    }\n                    addScope.widgets = widgets;\n\n                    //pass translate function to the new scope so we can translate the labels inside the modal dialog\n                    addScope.translate = $scope.translate;\n\n                    var adfAddTemplatePath = adfTemplatePath + 'widget-add.html';\n                    if (model.addTemplateUrl) {\n                        adfAddTemplatePath = model.addTemplateUrl;\n                    }\n\n                    var opts = {\n                        scope: addScope,\n                        templateUrl: adfAddTemplatePath,\n                        backdrop: 'static'\n                    };\n                    var instance = $modal.open(opts);\n                    addScope.addWidget = function (widget) {\n                        var w = {\n                            type: widget,\n                            config: createConfiguration(widget)\n                        };\n                        addNewWidgetToModel(model, w);\n                        $rootScope.$broadcast('adfWidgetAdded', name, model, w);\n                        // close and destroy\n                        instance.close();\n                        addScope.$destroy();\n                    };\n                    addScope.closeDialog = function () {\n                        // close and destroy\n                        instance.close();\n                        addScope.$destroy();\n                    };\n                };\n            },\n            link: function ($scope, $element, $attr) {\n                // pass options to scope\n                var options = {\n                    name: $attr.name,\n                    editable: true,\n                    enableConfirmDelete: stringToBoolean($attr.enableconfirmdelete),\n                    maximizable: stringToBoolean($attr.maximizable),\n                    collapsible: stringToBoolean($attr.collapsible)\n                };\n                if (angular.isDefined($attr.editable)) {\n                    options.editable = stringToBoolean($attr.editable);\n                }\n                $scope.options = options;\n            },\n            templateUrl: adfTemplatePath + 'dashboard.html'\n        };\n    });\n\n/*\n * The MIT License\n *\n * Copyright (c) 2015, Sebastian Sdorra\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n\n/**\n * @ngdoc object\n * @name adf.dashboardProvider\n * @description\n *\n * The dashboardProvider can be used to register structures and widgets.\n */\nangular.module('adf.provider', ['adf.locale'])\n    .provider('dashboard', function (adfLocale) {\n\n        var activeLocale = adfLocale.defaultLocale;\n        var locales = adfLocale.frameworkLocales;\n\n        function getLocales() {\n            return locales;\n        }\n\n        function getActiveLocale() {\n            return activeLocale;\n        }\n\n        function translate(label) {\n            var translation = locales[activeLocale][label];\n            return translation ? translation : label;\n        }\n\n        this.setLocale = function (locale) {\n            if (locales[locale]) {\n                activeLocale = locale;\n            } else {\n                throw new Error('Cannot set locale: ' + locale + '. Locale is not defined.');\n            }\n\n            return this;\n        };\n        this.addLocale = function (locale, translations) {\n            if (!angular.isString(locale)) {\n                throw new Error('locale must be an string');\n            }\n\n            if (!angular.isObject(translations)) {\n                throw new Error('translations must be an object');\n            }\n\n            locales[locale] = translations;\n            return this;\n        };\n\n        var customWidgetTemplatePath = null;\n\n        /**\n         * @ngdoc method\n         * @name adf.dashboardProvider#customWidgetTemplatePath\n         * @propertyOf adf.dashboardProvider\n         * @description\n         *\n         * Changes the container template for the widgets\n         *\n         * @param {string} path to the custom widget template\n         *\n         * @returns {Object} self\n         */\n        this.customWidgetTemplatePath = function (templatePath) {\n            customWidgetTemplatePath = templatePath;\n            return this;\n        };\n\n        var widgets = {};\n        var widgetsPath = '';\n        var structures = {};\n        var messageTemplate = '<div class=\"alert alert-danger\">{}</div>';\n        var loadingTemplate = '\\\n      <div class=\"progress progress-striped active\">\\n\\\n        <div class=\"progress-bar\" role=\"progressbar\" style=\"width: 100%\">\\n\\\n          <span class=\"sr-only\">loading ...</span>\\n\\\n        </div>\\n\\\n      </div>';\n\n        /**\n         * @ngdoc method\n         * @name adf.dashboardProvider#widget\n         * @methodOf adf.dashboardProvider\n         * @description\n         *\n         * Registers a new widget.\n         *\n         * @param {string} name of the widget\n         * @param {object} widget to be registered.\n         *\n         *   Object properties:\n         *\n         *   - `title` - `{string=}` - The title of the widget.\n         *   - `description` - `{string=}` - Description of the widget.\n         *   - `config` - `{object}` - Predefined widget configuration.\n         *   - `controller` - `{string=|function()=}` - Controller fn that should be\n         *      associated with newly created scope of the widget or the name of a\n         *      {@link http://docs.angularjs.org/api/angular.Module#controller registered controller}\n         *      if passed as a string.\n         *   - `controllerAs` - `{string=}` - A controller alias name. If present the controller will be\n         *      published to scope under the `controllerAs` name.\n         *   - `template` - `{string=|function()=}` - html template as a string.\n         *   - `templateUrl` - `{string=}` - path to an html template.\n         *   - `reload` - `{boolean=}` - true if the widget could be reloaded. The default is false.\n         *   - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\n         *      be injected into the controller. If any of these dependencies are promises, the widget\n         *      will wait for them all to be resolved or one to be rejected before the controller is\n         *      instantiated.\n         *      If all the promises are resolved successfully, the values of the resolved promises are\n         *      injected.\n         *\n         *      The map object is:\n         *      - `key` – `{string}`: a name of a dependency to be injected into the controller.\n         *      - `factory` - `{string|function}`: If `string` then it is an alias for a service.\n         *        Otherwise if function, then it is {@link http://docs.angularjs.org/api/AUTO.$injector#invoke injected}\n         *        and the return value is treated as the dependency. If the result is a promise, it is\n         *        resolved before its value is injected into the controller.\n         *   - `edit` - `{object}` - Edit modus of the widget.\n         *      - `controller` - `{string=|function()=}` - Same as above, but for the edit mode of the widget.\n         *      - `template` - `{string=|function()=}` - Same as above, but for the edit mode of the widget.\n         *      - `templateUrl` - `{string=}` - Same as above, but for the edit mode of the widget.\n         *      - `resolve` - `{Object.<string, function>=}` - Same as above, but for the edit mode of the widget.\n         *      - `reload` - {boolean} - true if the widget should be reloaded, after the edit mode is closed.\n         *        Default is true.\n         *\n         * @returns {Object} self\n         */\n        this.widget = function (name, widget) {\n            var w = angular.extend({reload: false}, widget);\n            if (w.edit) {\n                var edit = {reload: true};\n                angular.extend(edit, w.edit);\n                w.edit = edit;\n            }\n            widgets[name] = w;\n            return this;\n        };\n\n        /**\n         * @ngdoc method\n         * @name adf.dashboardProvider#widgetsPath\n         * @methodOf adf.dashboardProvider\n         * @description\n         *\n         * Sets the path to the directory which contains the widgets. The widgets\n         * path is used for widgets with a templateUrl which contains the\n         * placeholder {widgetsPath}. The placeholder is replaced with the\n         * configured value, before the template is loaded, but the template is\n         * cached with the unmodified templateUrl (e.g.: {widgetPath}/src/widgets).\n         * The default value of widgetPaths is ''.\n         *\n         *\n         * @param {string} path to the directory which contains the widgets\n         *\n         * @returns {Object} self\n         */\n        this.widgetsPath = function (path) {\n            widgetsPath = path;\n            return this;\n        };\n\n        /**\n         * @ngdoc method\n         * @name adf.dashboardProvider#structure\n         * @methodOf adf.dashboardProvider\n         * @description\n         *\n         * Registers a new structure.\n         *\n         * @param {string} name of the structure\n         * @param {object} structure to be registered.\n         *\n         *   Object properties:\n         *\n         *   - `rows` - `{Array.<Object>}` - Rows of the dashboard structure.\n         *     - `styleClass` - `{string}` - CSS Class of the row.\n         *     - `columns` - `{Array.<Object>}` - Columns of the row.\n         *       - `styleClass` - `{string}` - CSS Class of the column.\n         *\n         * @returns {Object} self\n         */\n        this.structure = function (name, structure) {\n            structures[name] = structure;\n            return this;\n        };\n\n        /**\n         * @ngdoc method\n         * @name adf.dashboardProvider#messageTemplate\n         * @methodOf adf.dashboardProvider\n         * @description\n         *\n         * Changes the template for messages.\n         *\n         * @param {string} template for messages.\n         *\n         * @returns {Object} self\n         */\n        this.messageTemplate = function (template) {\n            messageTemplate = template;\n            return this;\n        };\n\n        /**\n         * @ngdoc method\n         * @name adf.dashboardProvider#loadingTemplate\n         * @methodOf adf.dashboardProvider\n         * @description\n         *\n         * Changes the template which is displayed as\n         * long as the widget resources are not resolved.\n         *\n         * @param {string} loading template\n         *\n         * @returns {Object} self\n         */\n        this.loadingTemplate = function (template) {\n            loadingTemplate = template;\n            return this;\n        };\n\n        /**\n         * @ngdoc service\n         * @name adf.dashboard\n         * @description\n         *\n         * The dashboard holds all options, structures and widgets.\n         *\n         * @property {Array.<Object>} widgets Array of registered widgets.\n         * @property {string} widgetsPath Default path for widgets.\n         * @property {Array.<Object>} structures Array of registered structures.\n         * @property {string} messageTemplate Template for messages.\n         * @property {string} loadingTemplate Template for widget loading.\n         *\n         * @returns {Object} self\n         */\n        this.$get = function () {\n            var cid = 0;\n\n            return {\n                widgets: widgets,\n                widgetsPath: widgetsPath,\n                structures: structures,\n                messageTemplate: messageTemplate,\n                loadingTemplate: loadingTemplate,\n                setLocale: this.setLocale,\n                locales: getLocales,\n                activeLocale: getActiveLocale,\n                translate: translate,\n                customWidgetTemplatePath: customWidgetTemplatePath,\n\n                /**\n                 * @ngdoc method\n                 * @name adf.dashboard#id\n                 * @methodOf adf.dashboard\n                 * @description\n                 *\n                 * Creates an ongoing numeric id. The method is used to create ids for\n                 * columns and widgets in the dashboard.\n                 */\n                id: function () {\n                    return ++cid;\n                }\n            };\n        };\n\n    });\n\n/*\n* The MIT License\n*\n* Copyright (c) 2015, Sebastian Sdorra\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in\n* all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\n\n/* global angular */\nangular.module('adf')\n    .directive('adfDashboardRow', function ($compile, adfTemplatePath, columnTemplate) {\n        \n\n        return {\n            restrict: 'E',\n            replace: true,\n            scope: {\n                row: '=',\n                adfModel: '=',\n                editMode: '=',\n                options: '='\n            },\n            templateUrl: adfTemplatePath + 'dashboard-row.html',\n            link: function ($scope, $element) {\n                if (angular.isDefined($scope.row.columns) && angular.isArray($scope.row.columns)) {\n                    $compile(columnTemplate)($scope, function (cloned) {\n                        $element.append(cloned);\n                    });\n                }\n            }\n        };\n    });\n\n/*\n * The MIT License\n *\n * Copyright (c) 2015, Sebastian Sdorra\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n\nangular.module('adf')\n    .directive('adfWidgetContent', function ($log, $q, $sce, $http, $templateCache,\n                                             $compile, $controller, $injector, dashboard) {\n\n        function parseUrl(url) {\n            var parsedUrl = url;\n            if (url.indexOf('{widgetsPath}') >= 0) {\n                parsedUrl = url.replace('{widgetsPath}', dashboard.widgetsPath)\n                    .replace('//', '/');\n                if (parsedUrl.indexOf('/') === 0) {\n                    parsedUrl = parsedUrl.substring(1);\n                }\n            }\n            return parsedUrl;\n        }\n\n        function getTemplate(widget) {\n            var deferred = $q.defer();\n\n            if (widget.template) {\n                deferred.resolve(widget.template);\n            } else if (widget.templateUrl) {\n                // try to fetch template from cache\n                var tpl = $templateCache.get(widget.templateUrl);\n                if (tpl) {\n                    deferred.resolve(tpl);\n                } else {\n                    var url = $sce.getTrustedResourceUrl(parseUrl(widget.templateUrl));\n                    //$http.get(url)\n                    //  .success(function(response){\n                    //    // put response to cache, with unmodified url as key\n                    //    $templateCache.put(widget.templateUrl, response);\n                    //    deferred.resolve(response);\n                    //  })\n                    //  .error(function(){\n                    //    deferred.reject('could not load template');\n                    //  });\n\n                    //jwu: above code not working\n                    $http.get(url).then(function (response) {\n                        // put response to cache, with unmodified url as key\n                        $templateCache.put(widget.templateUrl, response.data);\n                        deferred.resolve(response.data);\n                    }, (function () {\n                        deferred.reject('could not load template');\n                    }));\n                }\n            }\n\n            return deferred.promise;\n        }\n\n        function compileWidget($scope, $element, currentScope) {\n            var model = $scope.model;\n            var content = $scope.content;\n\n            // display loading template\n            $element.html(dashboard.loadingTemplate);\n\n            // create new scope\n            var templateScope = $scope.$new();\n\n            // pass config object to scope\n            if (!model.config) {\n                model.config = {};\n            }\n\n            templateScope.config = model.config;\n\n            // local injections\n            var base = {\n                $scope: templateScope,\n                widget: model,\n                config: model.config\n            };\n\n            // get resolve promises from content object\n            var resolvers = {};\n            resolvers.$tpl = getTemplate(content);\n            if (content.resolve) {\n                angular.forEach(content.resolve, function (promise, key) {\n                    if (angular.isString(promise)) {\n                        resolvers[key] = $injector.get(promise);\n                    } else {\n                        resolvers[key] = $injector.invoke(promise, promise, base);\n                    }\n                });\n            }\n\n            // resolve all resolvers\n            $q.all(resolvers).then(function (locals) {\n                angular.extend(locals, base);\n\n                // compile & render template\n                var template = locals.$tpl;\n                $element.html(template);\n                if (content.controller) {\n                    var templateCtrl = $controller(content.controller, locals);\n                    if (content.controllerAs) {\n                        templateScope[content.controllerAs] = templateCtrl;\n                    }\n                    $element.children().data('$ngControllerController', templateCtrl);\n                }\n                $compile($element.contents())(templateScope);\n            }, function (reason) {\n                // handle promise rejection\n                var msg = 'Could not resolve all promises';\n                if (reason) {\n                    msg += ': ' + reason;\n                }\n                $log.warn(msg);\n                $element.html(dashboard.messageTemplate.replace(/{}/g, msg));\n            });\n\n            // destroy old scope\n            if (currentScope) {\n                currentScope.$destroy();\n            }\n\n            return templateScope;\n        }\n\n        return {\n            replace: true,\n            restrict: 'EA',\n            transclude: false,\n            scope: {\n                model: '=',\n                content: '='\n            },\n            link: function ($scope, $element) {\n                var currentScope = compileWidget($scope, $element, null);\n                $scope.$on('widgetConfigChanged', function () {\n                    currentScope = compileWidget($scope, $element, currentScope);\n                });\n                $scope.$on('widgetReload', function () {\n                    currentScope = compileWidget($scope, $element, currentScope);\n                });\n            }\n        };\n\n    });\n\n/*\n * The MIT License\n *\n * Copyright (c) 2015, Sebastian Sdorra\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n\nangular.module('adf')\n    .directive('adfWidget', function ($log, $modal, dashboard, adfTemplatePath) {\n\n        function preLink($scope) {\n            var definition = $scope.definition;\n\n            //passs translate function from dashboard so we can translate labels inside html templates\n            $scope.translate = dashboard.translate;\n\n            if (definition) {\n                var w = dashboard.widgets[definition.type];\n                if (w) {\n                    // pass title\n                    if (!definition.title) {\n                        definition.title = w.title;\n                    }\n\n                    if (!definition.titleTemplateUrl) {\n                        definition.titleTemplateUrl = adfTemplatePath + 'widget-title.html';\n                        if (w.titleTemplateUrl) {\n                            definition.titleTemplateUrl = w.titleTemplateUrl;\n                        }\n                    }\n                    if (!definition.deleteTemplateUrl) {\n                        definition.deleteTemplateUrl = adfTemplatePath + 'widget-delete.html';\n                        if (w.deleteTemplateUrl) {\n                            definition.deleteTemplateUrl = w.deleteTemplateUrl;\n                        }\n                    }\n                    if (!definition.editTemplateUrl) {\n                        definition.editTemplateUrl = adfTemplatePath + 'widget-edit.html';\n                        if (w.editTemplateUrl) {\n                            definition.editTemplateUrl = w.editTemplateUrl;\n                        }\n                    }\n                    if (!definition.fullscreenTemplateUrl) {\n                        definition.fullscreenTemplateUrl = adfTemplatePath + 'widget-fullscreen.html';\n                        if (w.fullscreenTemplateUrl) {\n                            definition.fullscreenTemplateUrl = w.fullscreenTemplateUrl;\n                        }\n                    }\n\n\n                    // set id for sortable\n                    if (!definition.wid) {\n                        definition.wid = dashboard.id();\n                    }\n\n                    // pass copy of widget to scope\n                    $scope.widget = angular.copy(w);\n\n                    // create config object\n                    var config = definition.config;\n                    if (config) {\n                        if (angular.isString(config)) {\n                            config = angular.fromJson(config);\n                        }\n                    } else {\n                        config = {};\n                    }\n\n                    // pass config to scope\n                    $scope.config = config;\n\n                    // collapse exposed $scope.widgetState property\n                    if (!$scope.widgetState) {\n                        $scope.widgetState = {};\n                        $scope.widgetState.isCollapsed = false;\n                    }\n\n                } else {\n                    $log.warn('could not find widget ' + definition.type);\n                }\n            } else {\n                $log.debug('definition not specified, widget was probably removed');\n            }\n        }\n\n        function postLink($scope, $element) {\n            var definition = $scope.definition;\n            if (definition) {\n                // bind close function\n\n                var deleteWidget = function () {\n                    var column = $scope.col;\n                    if (column) {\n                        var index = column.widgets.indexOf(definition);\n                        if (index >= 0) {\n                            column.widgets.splice(index, 1);\n                        }\n                    }\n                    $element.remove();\n                };\n                $scope.remove = function () {\n                    if ($scope.options.enableConfirmDelete) {\n                        var deleteScope = $scope.$new();\n                        deleteScope.translate = dashboard.translate;\n\n                        var adfDeleteTemplatePath = (definition.deleteTemplateUrl) ? definition.deleteTemplateUrl\n                            : adfTemplatePath + 'widget-delete.html';\n\n                        var opts = {\n                            scope: deleteScope,\n                            templateUrl: adfDeleteTemplatePath,\n                            backdrop: 'static'\n                        };\n                        var instance = $modal.open(opts);\n\n                        deleteScope.closeDialog = function () {\n                            instance.close();\n                            deleteScope.$destroy();\n                        };\n                        deleteScope.deleteDialog = function () {\n                            deleteWidget();\n                            deleteScope.closeDialog();\n                        };\n                    }\n                    else {\n                        deleteWidget();\n                    }\n                };\n\n                // bind reload function\n                $scope.reload = function () {\n                    $scope.$broadcast('widgetReload');\n                };\n\n                // bind edit function\n                $scope.edit = function () {\n                    var editScope = $scope.$new();\n                    editScope.translate = dashboard.translate;\n                    editScope.definition = angular.copy(definition);\n\n                    var adfEditTemplatePath = (definition.editTemplateUrl) ? definition.editTemplateUrl\n                        : adfTemplatePath + 'widget-edit.html';\n\n                    var opts = {\n                        scope: editScope,\n                        templateUrl: adfEditTemplatePath,\n                        backdrop: 'static'\n                    };\n\n                    var instance = $modal.open(opts);\n                    editScope.closeDialog = function () {\n                        instance.close();\n                        editScope.$destroy();\n\n                        var widget = $scope.widget;\n                        if (widget.edit && widget.edit.reload) {\n                            // reload content after edit dialog is closed\n                            $scope.$broadcast('widgetConfigChanged');\n                        }\n                    };\n                    editScope.saveDialog = function () {\n                        definition.title = editScope.definition.title;\n                        angular.extend(definition.config, editScope.definition.config);\n                        editScope.closeDialog();\n                    };\n                };\n            } else {\n                $log.debug('widget not found');\n            }\n        }\n\n        return {\n            replace: true,\n            restrict: 'EA',\n            transclude: false,\n            templateUrl: dashboard.customWidgetTemplatePath ? dashboard.customWidgetTemplatePath : adfTemplatePath + 'widget.html',\n            scope: {\n                definition: '=',\n                col: '=column',\n                editMode: '=',\n                options: '=',\n                widgetState: '='\n            },\n\n            controller: function ($scope) {\n\n                $scope.$on(\"adfDashboardCollapseExapand\", function (event, args) {\n                    $scope.widgetState.isCollapsed = args.collapseExpandStatus;\n                });\n\n                $scope.openFullScreen = function () {\n                    var definition = $scope.definition;\n                    var fullScreenScope = $scope.$new();\n                    fullScreenScope.translate = dashboard.translate;\n\n                    var fullscreenTemplateUrl = (definition.fullscreenTemplateUrl) ? definition.fullscreenTemplateUrl\n                        : adfTemplatePath + 'widget-fullscreen.html';\n\n                    var opts = {\n                        scope: fullScreenScope,\n                        templateUrl: fullscreenTemplateUrl,\n                        size: definition.modalSize || 'lg', // 'sm', 'lg'\n                        backdrop: 'static',\n                        windowClass: (definition.fullScreen) ? 'dashboard-modal widget-fullscreen' : 'dashboard-modal'\n                    };\n\n                    var instance = $modal.open(opts);\n                    fullScreenScope.closeDialog = function () {\n                        instance.close();\n                        fullScreenScope.$destroy();\n                    };\n                };\n            },\n\n            compile: function compile() {\n\n                /**\n                 * use pre link, because link of widget-content\n                 * is executed before post link widget\n                 */\n                return {\n                    pre: preLink,\n                    post: postLink\n                };\n            }\n        };\n\n    });\n\nangular.module(\"adf\").run([\"$templateCache\", function($templateCache) {$templateCache.put(\"../src/templates/dashboard-column.html\",\"<div adf-id={{column.cid}} class=column ng-class=column.styleClass ng-model=column.widgets> <adf-widget ng-repeat=\\\"definition in column.widgets\\\" definition=definition column=column edit-mode=editMode options=options widget-state=widgetState>  </adf-widget></div> \");\n$templateCache.put(\"../src/templates/dashboard-edit.html\",\"<div class=modal-header> <button type=button class=close ng-click=closeDialog() aria-hidden=true>&times;</button> <h4 class=modal-title ng-bind=\\\"translate(\\'ADF_COMMON_EDIT_DASHBOARD\\')\\\">Edit Dashboard</h4> </div> <div class=modal-body> <form role=form> <div class=form-group> <label for=dashboardTitle ng-bind=\\\"translate(\\'ADF_COMMON_TITLE\\')\\\">Title</label> <input type=text class=form-control id=dashboardTitle ng-model=copy.title required> </div> <div class=form-group> <label ng-bind=\\\"translate(\\'ADF_EDIT_DASHBOARD_STRUCTURE_LABEL\\')\\\">Structure</label> <div class=radio ng-repeat=\\\"(key, structure) in structures\\\"> <label> <input type=radio value={{key}} ng-model=model.structure ng-change=\\\"changeStructure(key, structure)\\\"> {{key}} </label> </div> </div> </form> </div> <div class=modal-footer> <button type=button class=\\\"btn btn-primary\\\" ng-click=closeDialog() ng-bind=\\\"translate(\\'ADF_COMMON_CLOSE\\')\\\">Close</button> </div> \");\n$templateCache.put(\"../src/templates/dashboard-row.html\",\"<div class=row ng-class=row.styleClass>  </div> \");\n$templateCache.put(\"../src/templates/dashboard-title.html\",\"<h1> {{model.title}} <span style=\\\"font-size: 16px\\\" class=pull-right> <a href ng-if=editMode title=\\\"{{ translate(\\'ADF_DASHBOARD_TITLE_TOOLTIP_ADD\\') }}\\\" ng-click=addWidgetDialog()> <i class=\\\"glyphicon glyphicon-plus-sign\\\"></i> </a> <a href ng-if=editMode title=\\\"{{ translate(\\'ADF_COMMON_EDIT_DASHBOARD\\') }}\\\" ng-click=editDashboardDialog()> <i class=\\\"glyphicon glyphicon-cog\\\"></i> </a> <a href ng-if=options.editable title=\\\"{{editMode ? translate(\\'ADF_DASHBOARD_TITLE_TOOLTIP_SAVE\\') : translate(\\'ADF_DASHBOARD_TITLE_TOOLTIP_EDIT_MODE\\') }}\\\" ng-click=toggleEditMode()> <i class=glyphicon x-ng-class=\\\"{\\'glyphicon-edit\\' : !editMode, \\'glyphicon-save\\' : editMode}\\\"></i> </a> <a href ng-if=editMode title=\\\"{{ translate(\\'ADF_DASHBOARD_TITLE_TOOLTIP_UNDO\\') }}\\\" ng-click=cancelEditMode()> <i class=\\\"glyphicon glyphicon-repeat adf-flip\\\"></i> </a> </span> </h1> \");\n$templateCache.put(\"../src/templates/dashboard.html\",\"<div class=dashboard-container> <div ng-include src=model.titleTemplateUrl></div> <div class=dashboard x-ng-class=\\\"{\\'edit\\' : editMode}\\\"> <adf-dashboard-row row=row adf-model=model options=options ng-repeat=\\\"row in model.rows\\\" edit-mode=editMode> </adf-dashboard-row></div> </div> \");\n$templateCache.put(\"../src/templates/widget-add.html\",\"<div class=modal-header> <button type=button class=close ng-click=closeDialog() aria-hidden=true>&times;</button> <h4 class=modal-title ng-bind=\\\"translate(\\'ADF_WIDGET_ADD_HEADER\\')\\\">Add new widget</h4> </div> <div class=modal-body> <div style=\\\"display: inline-block;\\\"> <dl class=dl-horizontal> <dt ng-repeat-start=\\\"(key, widget) in widgets\\\"> <a href ng-click=addWidget(key)> {{widget.title}} </a> </dt> <dd ng-repeat-end ng-if=widget.description> {{widget.description}} </dd> </dl> </div> </div> <div class=modal-footer> <button type=button class=\\\"btn btn-primary\\\" ng-click=closeDialog() ng-bind=\\\"translate(\\'ADF_COMMON_CLOSE\\')\\\">Close</button> </div> \");\n$templateCache.put(\"../src/templates/widget-delete.html\",\"<div class=modal-header> <h4 class=modal-title><span ng-bind=\\\"translate(\\'ADF_COMMON_DELETE\\')\\\">Delete</span> {{widget.title}}</h4> </div> <div class=modal-body> <form role=form> <div class=form-group> <label for=widgetTitle ng-bind=\\\"translate(\\'ADF_WIDGET_DELETE_CONFIRM_MESSAGE\\')\\\">Are you sure you want to delete this widget ?</label> </div> </form> </div> <div class=modal-footer> <button type=button class=\\\"btn btn-default\\\" ng-click=closeDialog() ng-bind=\\\"translate(\\'ADF_COMMON_CLOSE\\')\\\">Close</button> <button type=button class=\\\"btn btn-primary\\\" ng-click=deleteDialog() ng-bind=\\\"translate(\\'ADF_COMMON_DELETE\\')\\\">Delete</button> </div> \");\n$templateCache.put(\"../src/templates/widget-edit.html\",\"<div class=modal-header> <button type=button class=close ng-click=closeDialog() aria-hidden=true>&times;</button> <h4 class=modal-title>{{widget.title}}</h4> </div> <div class=modal-body> <form role=form> <div class=form-group> <label for=widgetTitle ng-bind=\\\"translate(\\'ADF_COMMON_TITLE\\')\\\">Title</label> <input type=text class=form-control id=widgetTitle ng-model=definition.title placeholder=\\\"Enter title\\\" required> </div> </form> <div ng-if=widget.edit> <adf-widget-content model=definition content=widget.edit> </adf-widget-content></div> </div> <div class=modal-footer> <button type=button class=\\\"btn btn-default\\\" ng-click=closeDialog() ng-bind=\\\"translate(\\'ADF_COMMON_CANCEL\\')\\\">Cancel</button> <button type=button class=\\\"btn btn-primary\\\" ng-click=saveDialog() ng-bind=\\\"translate(\\'ADF_COMMON_APPLY\\')\\\">Apply</button> </div> \");\n$templateCache.put(\"../src/templates/widget-fullscreen.html\",\"<div class=modal-header> <div class=\\\"pull-right widget-icons\\\"> <a href title=\\\"Reload Widget Content\\\" ng-if=widget.reload ng-click=reload()> <i class=\\\"glyphicon glyphicon-refresh\\\"></i> </a> <a href title=close ng-click=closeDialog()> <i class=\\\"glyphicon glyphicon-remove\\\"></i> </a> </div> <h4 class=modal-title>{{definition.title}}</h4> </div> <div class=modal-body> <adf-widget-content model=definition content=widget> </adf-widget-content></div> <div class=modal-footer> <button type=button class=\\\"btn btn-primary\\\" ng-click=closeDialog()>Close</button> </div> \");\n$templateCache.put(\"../src/templates/widget-title.html\",\"<h3 class=panel-title> {{definition.title}} <span class=pull-right> <a href title=\\\"{{ translate(\\'ADF_WIDGET_TOOLTIP_REFRESH\\') }}\\\" ng-if=widget.reload ng-click=reload()> <i class=\\\"glyphicon glyphicon-refresh\\\"></i> </a>  <a href title=\\\"{{ translate(\\'ADF_WIDGET_TOOLTIP_MOVE\\') }}\\\" class=adf-move ng-if=editMode> <i class=\\\"glyphicon glyphicon-move\\\"></i> </a>  <a href title=\\\"{{ translate(\\'ADF_WIDGET_TOOLTIP_COLLAPSE\\') }}\\\" ng-show=\\\"options.collapsible && !widgetState.isCollapsed\\\" ng-click=\\\"widgetState.isCollapsed = !widgetState.isCollapsed\\\"> <i class=\\\"glyphicon glyphicon-minus\\\"></i> </a>  <a href title=\\\"{{ translate(\\'ADF_WIDGET_TOOLTIP_EXPAND\\') }}\\\" ng-show=\\\"options.collapsible && widgetState.isCollapsed\\\" ng-click=\\\"widgetState.isCollapsed = !widgetState.isCollapsed\\\"> <i class=\\\"glyphicon glyphicon-plus\\\"></i> </a>  <a href title=\\\"{{ translate(\\'ADF_WIDGET_TOOLTIP_EDIT\\') }}\\\" ng-click=edit() ng-if=editMode> <i class=\\\"glyphicon glyphicon-cog\\\"></i> </a> <a href title=\\\"{{ translate(\\'ADF_WIDGET_TOOLTIP_FULLSCREEN\\') }}\\\" ng-click=openFullScreen() ng-show=options.maximizable> <i class=\\\"glyphicon glyphicon-fullscreen\\\"></i> </a>  <a href title=\\\"{{ translate(\\'ADF_WIDGET_TOOLTIP_REMOVE\\') }}\\\" ng-click=remove() ng-if=editMode> <i class=\\\"glyphicon glyphicon-remove\\\"></i> </a> </span> </h3> \");\n$templateCache.put(\"../src/templates/widget.html\",\"<div adf-id={{definition.wid}} adf-widget-type={{definition.type}} class=\\\"widget panel panel-default\\\"> <div class=\\\"panel-heading clearfix\\\"> <div ng-include src=definition.titleTemplateUrl></div> </div> <div class=panel-body collapse=widgetState.isCollapsed> <adf-widget-content model=definition content=widget> </adf-widget-content></div> </div> \");}]);})(window);"]}